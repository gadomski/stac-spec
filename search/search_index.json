{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STAC specification","text":"<p>This is an HTML rendering of the SpatioTemporal Asset Catalog (STAC) specification. The specification consists of three parts:</p> <ul> <li>Item</li> <li>Collection</li> <li>Catalog</li> </ul> <p>The source for these documents is the stac-spec repository. Use issues for any bugs or other problems, and use discussions for questions or other conversations.</p> <p>The STAC API specification, which describes how STAC can be served and searched, lives in its own repository and is not included in these pages.</p>"},{"location":"best-practices/","title":"STAC Best Practices","text":""},{"location":"best-practices/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Web Best Practices</li> <li>Enable Cross-origin resource sharing (CORS)</li> <li>STAC on the Web<ul> <li>Schema.org, JSON-LD, DCAT, microformats, etc</li> <li>Deploying STAC Browser</li> </ul> </li> <li>Requester Pays</li> <li>Consistent URIs</li> <li>Item Best Practices</li> <li>Field and ID formatting</li> <li>Searchable Identifiers</li> <li>Field selection and Metadata Linking</li> <li>Datetime selection</li> <li>Unlocated Items</li> <li>Representing Vector Layers in STAC</li> <li>Asset and Link Best Practices</li> <li>Common Use Cases of Additional Fields for Assets</li> <li>Working with Media Types</li> <li>Asset Roles</li> <li>Bands</li> <li>Catalog &amp; Collection Best Practices</li> <li>Static and Dynamic Catalogs<ul> <li>Static Catalogs</li> <li>Dynamic Catalogs</li> </ul> </li> <li>Catalog Layout<ul> <li>Dynamic Catalog Layout</li> <li>Mixing STAC Versions</li> </ul> </li> <li>Using Summaries in Collections</li> <li>Use of links<ul> <li>Self-contained Catalogs</li> <li>Published Catalogs</li> </ul> </li> <li>Using Relation Types</li> <li>Versioning for Catalogs</li> <li>Static to Dynamic best practices<ul> <li>Ingestion and links</li> <li>Keep catalogs in sync with cloud notification and queue services</li> </ul> </li> <li>How to Differentiate STAC Files</li> </ul> <p>This document makes a number of recommendations for creating real world SpatioTemporal Asset Catalogs. None of them  are required to meet the core specification, but following these practices will make life easier for client tooling and for users. They come about from practical experience of implementors and introduce a bit more 'constraint' for those who are creating STAC objects representing their data or creating tools to work with STAC. </p> <p>While the current goal of the core is to remain quite flexible and simple to meet a wide variety of use cases, in time some of these may evolve to become part of the core specification.</p>"},{"location":"best-practices/#web-practices","title":"Web Practices","text":""},{"location":"best-practices/#enable-cross-origin-resource-sharing-cors","title":"Enable Cross-origin resource sharing (CORS)","text":"<p>STAC strives to make geospatial information more accessible, by putting it on the web. Fundamental to STAC's vision is that different tools will be able to load and display public-facing STAC data. But the web runs on a Same origin  policy, preventing web pages from loading information from other web locations to prevent malicious scripts from accessing sensitive data. This means that by default a web page would only be able to load STAC Item objects from the same server the page is on. Cross-origin resource sharing, also known as 'CORS' is a protocol to enable safe communication across origins. But most web services turn it off by default. This is generally a good thing, but unfortunately if CORS is not enabled then any browser-based STAC tool will not work. </p> <p>So to enable all the great web tools (like stacindex.org) to work with your STAC implementation it is essential to 'enable CORS'. Most services have good resources on how to do this, like on AWS S3, Google Cloud Storage, or Apache Server.  Many more are listed on enable-cors.org. We recommend enabling CORS for all requests ('*'), so that diverse online tools can access your data. If you aren't sure if your server has CORS enabled you can use  test-cors.org. Enter the URL of your STAC root Catalog or Collection JSON and make sure it gets a response.</p>"},{"location":"best-practices/#stac-on-the-web","title":"STAC on the Web","text":"<p>One of the primary goals of STAC is to make spatiotemporal data more accessible on the web. One would have a right to be  surprised that there is nothing about HTML in the entire specification. This is because it is difficult to specify what  should be on web pages without ending up with very bad looking pages. But the importance of having web-accessible versions of every STAC Item is paramount.</p> <p>The main recommendation is to have an HTML page for every single STAC Item, Catalog and Collection. They should be visually pleasing,  crawlable by search engines and ideally interactive. The current best practice is to use a tool in the STAC ecosystem called STAC Browser. It can crawl most any valid STAC implementation and generate unique web pages for each Item and Catalog (or Collection). While it has a default look and feel, the design can easily be  modified to match an existing web presence. And it will automatically turn any Item with a Cloud Optimized  GeoTIFF asset into an interactive, zoomable web map (using tiles.rdnt.io to render the tiles on a leaflet map). It also attempts to encapsulate a number of best practices that enable  STAC Items to show up in search engines, though that part is still a work in progress - contributions to STAC Browser to help are welcome!</p> <p>Implementors are welcome to generate their own web pages, and additional tools that automatically transform STAC JSON into  html sites are encouraged. In time there will likely emerge a set of best practices from an array of tools, and we may be able to specify in the core standard how to make the right HTML pages. But for now it is useful for STAC implementations to focus on  making data available as JSON, and then leverage tools that can evolve at the same time to make the best HTML experience. This enables innovation on the web generation and search engine optimization to evolve independently from the core data.</p>"},{"location":"best-practices/#schemaorg-json-ld-dcat-microformats-etc","title":"Schema.org, JSON-LD, DCAT, microformats, etc","text":"<p>There is a strong desire to align STAC with the various web standards for data. These include schema.org  tags, JSON-LD (particularly for Google's dataset  search), DCAT and microformats. STAC aims to work with as many as possible. Thusfar it has not seemed to make sense to include any of them directly in the core STAC standard. They are all more intended to be a part of the HTML pages that search engines crawl, so the logical place to do the integration is by leveraging a tool that generates HTML  from STAC like STAC Browser. STAC Browser has implemented a mapping to  schema.org fields using JSON-LD, but the exact output is still being refined. It is on the roadmap to add in more mapping and do more testing of search engines crawling the HTML pages. </p>"},{"location":"best-practices/#deploying-stac-browser","title":"Deploying STAC Browser","text":"<p>Most public STAC implementations have a STAC Browser hosted at stacindex.org. Anyone with a public STAC implementation is welcome to have a STAC Browser instance hosted for free, just submit it to stacindex.org. But the stronger recommendation is to host a STAC Browser on your own domain, and to customize its  design to look and feel like your main web presence. STAC aims to be decentralized, so each STAC-compliant data catalog  should have its own location and just be part of the wider web.</p>"},{"location":"best-practices/#requester-pays","title":"Requester Pays","text":"<p>It is very common that large, freely available datasets are set up with a 'requester pays' configuration. This is an option  on AWS and on  Google Cloud, that enables data providers to make their data available to everyone, while the cloud platform charges access costs (such as per-request and data 'egress') to the user accessing the data. For popular datasets that are large in size the egress costs can be substantial, to the point where much less data would be available if the cost of distribution was always on the data provider.</p> <p>For data providers using STAC with requester pays buckets, there are two main recommendations:</p> <ol> <li>Put the STAC JSON in a separate bucket that is public for everyone and not requestor pays. This enables the STAC metadata    to be far more crawlable and searchable, but the cost of the egress of STAC files should be miniscule compared to that of    the actual data. The STAC community can help you work with cloud providers for potential free hosting if you are doing open    data as requestor pays and aren't able to pay the costs of a completely open STAC bucket, as they are most all supportive of    STAC (but no guarantees and it may be on an alternate cloud).</li> <li>For Asset href values to resources in a requestor pays bucket, use the cloud provider-specific protocol    (e.g., <code>s3://</code> on AWS and <code>gs://</code> on Google Cloud) instead of an <code>https://</code> url.    Most clients do not have special handling for <code>https://</code> links to cloud provider resources that require a requestor pays flag and authentication,    so they simply fail. Many clients have special handling for <code>s3://</code> or <code>gs://</code> URLs    that will add a requestor pays parameter and will apply appropriate authentication to the request.    Using cloud-specific protocols will at least give users an option to register a paid account and    allow the data provider to properly charge for access.     STAC-specific tools in turn can look for the cloud-specific protocols and know to use the requestor pays feature for that specific cloud platform.</li> </ol>"},{"location":"best-practices/#consistent-uris","title":"Consistent URIs","text":"<p>Links in STAC can be absolute or relative.</p> <p>Relative links must be resolved against a base URL, which is the absolute URI given in the link with the relation type <code>self</code>. If a <code>self</code> link is not provided, the absolute URI of the resource can be used as the base URL. If neither of them is available, relative links can usually not be resolved and the behavior is undefined.</p> <p>To resolve relative URIs, the base URIs must be precise and consistent. Having or not having a trailing slash is significant (except if no path component is provided in a URL, see example 8). Without a trailing slash, the last path component is identified as a \"file\" and will be removed while resolving URLs. This means that if the trailing slash is missing for a folder, a relative link would need to include the last path component again to resolve correctly (see example 4).</p> <p>To avoid issues it is recommended to consistently add a slash at the end of the URL if it doesn't point to a file.</p> <p>Examples:</p> # Base URL Relative URL Resolved URL 1 <code>https://example.com/folder/catalog.json</code> <code>item.json</code> <code>https://example.com/folder/item.json</code> 2 <code>https://example.com/folder</code> <code>item.json</code> <code>https://example.com/item.json</code> 3 <code>https://example.com/folder/</code> <code>item.json</code> <code>https://example.com/folder/item.json</code> 4 <code>https://example.com/folder</code> <code>folder/item.json</code> <code>https://example.com/folder/item.json</code> 5 <code>https://example.com/folder/</code> <code>folder/item.json</code> <code>https://example.com/folder/folder/item.json</code> 6 <code>https://example.com/another/folder</code> <code>../item.json</code> <code>https://example.com/item.json</code> 7 <code>https://example.com/another/folder/</code> <code>../item.json</code> <code>https://example.com/another/item.json</code> 8 <code>https://example.com</code> <code>folder/item.json</code> <code>https://example.com/folder/item.json</code> 9 <code>https://example.com/</code> <code>folder/item.json</code> <code>https://example.com/folder/item.json</code> <p>The relative URLs <code>folder/item.json</code> and <code>./folder/item.json</code> are equivalent.</p>"},{"location":"best-practices/#item-practices","title":"Item Practices","text":""},{"location":"best-practices/#item-ids","title":"Item IDs","text":"<p>When defining one's STAC properties and fields there are many choices to make on how to name various aspects of one's data. One of the key properties is the ID. The specification is quite flexible on ID's, primarily so that existing providers can easily use their same ID when they translate their data into STAC. It is STRONGLY RECOMMENDED that an item ID is unique per collection. The use of URI or file path reserved characters such as <code>:</code> or <code>/</code> is discouraged since this will result in percented encoded STAC API endpoints and it prevents the use of IDs as file names as recommended in the catalog layout best practices.</p>"},{"location":"best-practices/#searchable-identifiers","title":"Searchable Identifiers","text":"<p>When coming up with values for fields that contain searchable identifiers of some sort, like <code>constellation</code> or <code>platform</code>, it is recommended that the identifiers consist of only lowercase characters, numbers, <code>_</code>, and <code>-</code>. Examples include <code>sentinel-1a</code> (Sentinel-1), <code>landsat-8</code> (Landsat-8) and <code>envisat</code> (Envisat). This is to provide consistency for search across Collections, so that people can just search for <code>landsat-8</code>, instead of thinking through all the ways providers might have chosen to name it.</p>"},{"location":"best-practices/#field-selection-and-metadata-linking","title":"Field selection and Metadata Linking","text":"<p>In general STAC aims to be oriented around search, centered on the core fields that users will want to search on to find  imagery. The core is space and time, but there are often other metadata fields that are useful. While the specification is  flexible enough that providers can fill it with tens or even hundreds of fields of metadata, that is not recommended. If  providers have lots of metadata then that can be linked to in the Asset Object  (recommended) or in a Link Object. There is a lot of metadata that is only of relevance  to loading and processing data, and while STAC does not prohibit providers from putting those type of fields in their items,  it is not recommended. For very large catalogs (hundreds of millions of records), every additional field that is indexed will cost substantial money, so data providers are advised to just put the fields to be searched in STAC and STAC API providers don't have bloated indices that no one actually uses.</p>"},{"location":"best-practices/#datetime-selection","title":"Datetime selection","text":"<p>The <code>datetime</code> field in a STAC Item's properties is one of the most important parts of a STAC Item, providing the T (temporal) of  STAC. And it can also be one of the most confusing, especially for data that covers a range of times. For many types of data it is straightforward - it is the capture or acquisition time. But often data is processed from a range of captures - drones usually gather a set of images over an hour and put them into a single image, mosaics combine data from several months, and data cubes represent slices of data over a range of time. For all these cases the recommended path is to use <code>start_datetime</code> and  <code>end_datetime</code> fields from common metadata. The specification does allow one to set the  <code>datetime</code> field to <code>null</code>, but it is strongly recommended to populate the single <code>datetime</code> field, as that is what many clients  will search on. If it is at all possible to pick a nominal or representative datetime then that should be used. But sometimes that  is not possible, like a data cube that covers a time range from 1900 to 2000. Setting the datetime as 1950 would lead to it not being found if you searched 1990 to 2000.</p> <p>Extensions that describe particular types of data can and should define their <code>datetime</code> field to be more specific. For example a MODIS 8 day composite image can define the <code>datetime</code> to be the nominal date halfway between the two ranges. Another data type might choose to have <code>datetime</code> be the start. The key is to put in a date and time that will be useful for search, as that is the focus of STAC. If <code>datetime</code> is set to <code>null</code> then it is strongly recommended to use it in conjunction with an extension that explains why it should not be set for that type of data. </p>"},{"location":"best-practices/#unlocated-items","title":"Unlocated Items","text":"<p>Though the GeoJSON standard allows null geometries, in STAC we strongly recommend that every item have a geometry, since the general expectation of someone using a SpatioTemporal Catalog is to be able to query all data by space and time. But there are some use cases where it can make sense to create a STAC Item before it gets a geometry. The most common of these is 'level 1' satellite data, where an image is downlinked and cataloged before it has  been geospatially located. </p> <p>The recommendation for data that does not yet have a location is to follow the GeoJSON concept that it is an 'unlocated'  feature. So if the catalog has data that is not located then it can follow  GeoJSON and set the geometry to null. Though normally required, in this case the <code>bbox</code> field should not be included.</p> <p>Note that this recommendation is only for cases where data does not yet have a geometry and it cannot be estimated. There are further details on the two most commonly requested desired use cases for setting geometry to null:</p>"},{"location":"best-practices/#unrectified-satellite-data","title":"Unrectified Satellite Data","text":"<p>Most satellite data is downlinked without information that precisely describes where it is located on Earth. A satellite  imagery processing pipeline will always attempt to locate it, but often that process takes a number of hours, or never quite completes (like when it is too cloudy). It can be useful to start to populate the Item before it has a geometry.  In this case the recommendation is to use the 'estimated' position from the satellite, to populate at least the bounding box, and use the same broad bounds for the geometry (or leaving it null) until there is precise ground lock. This estimation is  usually done by onboard equipment, like GPS or star trackers, but can be off by kilometers or more. But it is very useful for  STAC users to be able to at least find approximate area in their searches. A commonly used field for communicating ground lock  is not yet established, but likely should be (an extension proposal would be appreciated).  If there is no way to provide an  estimate then the data can be assigned a null geometry and no <code>bbox</code>, as described above. But the data will likely not show up in STAC API searches, as most will at least implicitly use a geometry. Though this section is written with  satellite data in mind, one can easily imagine other data types that start with a less precise geometry but have it  refined after processing.</p>"},{"location":"best-practices/#data-that-is-not-spatial","title":"Data that is not spatial","text":"<p>The other case that often comes up is people who love STAC and want to use it to catalog everything they have, even if it is not spatial. This use case is not currently supported by STAC, as we are focused on data that is both temporal and spatial in nature. The OGC API - Records is an emerging standard that likely will be able to handle a wider range of data than STAC. It builds on OGC API -  Features just like STAC API does. Using Collection Assets may also provide an option for some  use cases.</p>"},{"location":"best-practices/#representing-vector-layers-in-stac","title":"Representing Vector Layers in STAC","text":"<p>Many implementors are tempted to try to use STAC for 'everything', using it as a universal catalog of all their 'stuff'. The main route considered is to use STAC to describe vector layers, putting a shapefile or geopackage as the <code>asset</code>. Though there is nothing in the specification that prevents this, it is not really the right level of  abstraction. A shapefile or geopackage corresponds to a Collection, not a single Item. The ideal thing to do with one of those is to serve it with OGC API - Features standard. This allows each feature in the shapefile/geopackage to be represented online, and enables querying of the actual data. If that is not possible then the appropriate way to handle Collection-level search is with the  OGC API - Records standard, which is a 'brother' specification of STAC API.  Both are compliant with OGC API - Features, adding richer search capabilities to enable finding of data. </p>"},{"location":"best-practices/#asset-and-link-best-practices","title":"Asset and Link Best Practices","text":""},{"location":"best-practices/#common-use-cases-of-additional-fields-for-assets","title":"Common Use Cases of Additional Fields for Assets","text":"<p>As described in the Item spec, it is possible to use fields typically found in Item properties at the asset level. This mechanism of overriding or providing Item Properties only in the Assets  makes discovery more difficult and should generally be avoided. However, there are some core and extension fields for which  providing them at the Asset level can prove to be very useful for using the data.</p> <ul> <li><code>datetime</code>: Provide individual timestamp on an Item, in case the Item has a <code>start_datetime</code> and <code>end_datetime</code>,   but an Asset is for one specific time.</li> <li><code>gsd</code> (Common Metadata): Specify some assets that represent instruments    with different spatial resolution than the overall best resolution. Note this should not be used for different    spatial resolutions due to specific processing of assets - look into the raster    extension for that use case.</li> <li><code>bands</code> (e.g. in combination with the EO extension):   Provide spectral band information, and order of bands, within an individual asset.</li> <li><code>proj:code</code>/<code>proj:wkt2</code>/<code>proj:projjson</code> (projection extension):   Specify different projection for some assets. If the projection is different   for all assets it should probably not be provided as an Item property. If most assets are one projection, and there is    a single reprojected version (such as a Web Mercator preview image), it is sensible to specify the main projection in the    Item and the alternate projection for the affected asset(s).</li> <li><code>proj:shape</code>/<code>proj:transform</code> (projection extension):   If assets have different spatial resolutions and slightly different exact bounding boxes,   specify these per asset to indicate the size of the asset in pixels and its exact GeoTransform in the native projection.</li> <li><code>sar:polarizations</code> (sar extension):   Provide the polarization content and ordering of a specific asset.</li> <li><code>sar:product_type</code> (sar extension):   If mixing multiple product types within a single Item, this can be used to specify the product_type for each asset.</li> </ul>"},{"location":"best-practices/#titles","title":"Titles","text":"<p>It is recommended to always provide link titles. The link titles should always reflect the title of the entity it refers to. For example, if a STAC Item links to a STAC Collection, the value of the <code>title</code> property in the link with relation type <code>collection</code> should exactly match the value of the <code>title</code> property in the STAC Collection. Implementations should ensure that link titles are always synchronized so that inconsistencies don't occur.</p> <p>Providing titles enables users to search and navigate more easily through STAC catalogs, makes the links more predictable, and may prevent \"flickering\" in user-interfaces such as STAC Browser.</p> <p>If the entity that a link refers to has no title, the value of the <code>id</code> can be considered as an alternative.</p>"},{"location":"best-practices/#working-with-media-types","title":"Working with Media Types","text":"<p>Media Types are a key element that enables STAC to be a rich source of information for clients. The best practice is to use as specific of a media type as possible (so if a file is a GeoJSON then don't use a JSON media type), and to use registered IANA types as much as possible.</p> <p>For hierarchical links (e.g. relation types <code>root</code>, <code>parent</code>, <code>child</code>, <code>item</code>) it is important that clients filter for the corresponding STAC media types (e.g. <code>application/json</code> for all relation types and/or <code>application/geo+json</code> for relation type <code>item</code>).  Hierarchical links with other media types (e.g. <code>text/html</code>) may be present for hierarchical links, especially in STAC implementations that are also implementing OGC API - Records.</p>"},{"location":"best-practices/#common-media-types-in-stac","title":"Common Media Types in STAC","text":"<p>The following table lists a number of commonly used media types in STAC. The first two (GeoTIFF and COG) are not fully standardized  yet, but reflect the community consensus direction. There are many IANA registered types that commonly show up in STAC. The  following table lists some of the most common ones you may encounter or use.</p> Media Type Description <code>image/tiff; application=geotiff</code> GeoTIFF with standardized georeferencing metadata <code>image/tiff; application=geotiff; profile=cloud-optimized</code> Cloud Optimized GeoTIFF (unofficial). Once there is an official media type it will be added and the custom media type here will be deprecated. <code>image/jp2</code> JPEG 2000 <code>image/png</code> Visual PNGs (e.g. thumbnails) <code>image/jpeg</code> Visual JPEGs (e.g. thumbnails, oblique) <code>text/xml</code> or <code>application/xml</code> XML metadata RFC 7303 <code>application/json</code> A JSON file (often metadata, or labels) <code>text/plain</code> Plain text (often metadata) <code>application/geo+json</code> GeoJSON <code>application/geopackage+sqlite3</code> GeoPackage <code>application/x-hdf5</code> Hierarchical Data Format version 5 <code>application/x-hdf</code> Hierarchical Data Format versions 4 and earlier. <code>application/vnd.laszip+copc</code> COPC Cloud optimized PointCloud <code>application/vnd.apache.parquet</code> Apache Geoparquet <code>application/3dtiles+json</code> OGC 3D Tiles <code>application/vnd.pmtiles</code> Protomaps PMTiles <p>*Deprecation notice: GeoTiff previously used the media type <code>image/vnd.stac.geotiff</code> and Cloud Optimized GeoTiffs used <code>image/vnd.stac.geotiff; profile=cloud-optimized</code>. Both can still appear in old STAC implementations, but are deprecated and should be replaced.</p>"},{"location":"best-practices/#formats-with-no-registered-media-type","title":"Formats with no registered media type","text":"<p>This section gives recommendations on what to do if you have a format in your links or assets that does not have an IANA registered type. Ideally every media type used is on the IANA registry. If you are using a format that is not on that list we recommend you use custom content type. These typically use the <code>vnd.</code> prefix, see RFC 6838 section-3.2. Ideally the format provider will actually register the media type with IANA, so that other STAC clients can find it easily. But if you are only using it internally it is  acceptable to not register  it. It is relatively easy to register a <code>vnd</code> media type.</p>"},{"location":"best-practices/#asset-roles","title":"Asset Roles","text":"<p>Asset roles are used to describe what each asset is used for. They are particular useful  when several assets have the same media type, such as when an Item has a multispectral analytic asset, a 3-band full resolution  visual asset, a down-sampled preview asset, and a cloud mask asset, all stored as Cloud Optimized GeoTIFF (COG) images. It is  recommended to use at least one role for every asset available, and using multiple roles often makes sense. For example you'd use both <code>data</code> and <code>reflectance</code> if your main data asset is processed to reflectance, or <code>metadata</code> and <code>cloud</code> for an asset that  is a cloud mask, since a mask is considered a form of metadata (it's information about the data). Or if a single asset represents several types of 'unusable data' it might include <code>metadata</code>, <code>cloud</code>, <code>cloud-shadow</code> and <code>snow-ice</code>. If there is not a clear role then just pick a sensible name for the role. You are encouraged to add it to the list below and/or in an extension if you think the new role will have broader applicability. </p>"},{"location":"best-practices/#list-of-asset-roles","title":"List of Asset Roles","text":"<p>There are a number of roles that are commonly used in practice, which we recommend to reuse as much as possible. If you can't find suitable roles, feel free to suggest more.</p> Role Name Description data The data itself, excluding the metadata. metadata Metadata sidecar files describing the data, for example a Landsat-8 MTL file. thumbnail An asset that represents a thumbnail of the Item or Collection, typically a RGB or grayscale image primarily for human consumption, low resolution, restricted spatial extent, and displayable in a web browser without scripts or extensions. overview An asset that represents a more detailed overview of the Item or Collection, typically a RGB or grayscale image primarily for human consumption, medium resolution, full spatial extent, in a file format that's can be visualized easily (e.g., Cloud-Optimized GeoTiff). visual An asset that represents a detailed overview of the Item or Collection, typically a RGB or grayscale image primarily for human consumption, high or native resolution (often sharpened), full spatial extent, in a file format that's can be visualized easily (e.g., Cloud-Optimized GeoTiff). date An asset that provides per-pixel acquisition timestamps, typically serving as metadata to another asset graphic Supporting plot, illustration, or graph associated with the Item data-mask File indicating if corresponding pixels have Valid data and various types of invalid data snow-ice Points to a file that indicates whether a pixel is assessed as being snow/ice or not. land-water Points to a file that indicates whether a pixel is assessed as being land or water. water-mask Points to a file that indicates whether a pixel is assessed as being water (e.g. flooding map). iso-19115 Points to an ISO 19115 metadata file <p>Additional roles are defined in the various extensions, for example:</p> <ul> <li>EO Extension</li> <li>View Extension</li> <li>SAR Extension</li> </ul> <p>The roles <code>thumbnail</code>, <code>overview</code> and <code>visual</code> are very similar. To make choosing the right role easier, please consult the table below.</p> <p>They should usually be a RGB or grayscale image, which are primarily intended for human consumption, e.g., through a web browser. It can complement assets where one band is per file (like Landsat), by providing the key display bands combined, or can complement assets where many non-visible bands are included, by being a lighter weight file that just has the bands needed for display.</p> <p>Roles should also be combined, e.g., <code>thumbnail</code> and <code>overview</code> if the recommendations are all met.</p> <p>If your data for the Item does not come with a thumbnail already we do recommend generating one, which can be done quite easily with GDAL or Rasterio.</p> Role thumbnail overview visual Resolution Low Medium Native / High Recommended Image dimensions &lt; 600x600 px &lt; 5000x500 px any size Recommended File Formats PNG, JPEG, GIF, WebP PNG, JPEG, WebP, COG COG, other cloud-native and/or tiled file formats with pyramids, ... Spatial extent Limited Full Full Use case Quick overview, often in lists of items/collections Display for a single Item/Collection, sometimes shown on a web map Display for a single Item/Collection, often shown on a map, may be displayed in GIS software <p>The files offered for the roles <code>thumbnail</code>, <code>overview</code> and <code>visual</code> should be accessible via HTTP(S). If the Alternate Asset Extension is used, the default access mechanism should be HTTP(S).</p>"},{"location":"best-practices/#bands","title":"Bands","text":"<p>As of STAC 1.1, the <code>bands</code> array can be used in combination with property inheritance to provide users with more flexibility. The following best practices should be considered, especially when migrating from <code>eo:bands</code> and <code>raster:bands</code>.</p>"},{"location":"best-practices/#single-band","title":"Single band","text":"<p>Single band assets can be defined in two ways. Properties can be defined in the <code>bands</code> array or in the assets directly.</p> <p>Example using the <code>bands</code> array:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"bands\": [\n        {\n          \"data_type\": \"uint16\",\n          \"eo:common_name\": \"red\",\n          \"raster:spatial_resolution\": 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Example without bands:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"data_type\": \"uint16\",\n      \"eo:common_name\": \"red\",\n      \"raster:spatial_resolution\": 10\n    }\n  }\n}\n</code></pre> <p>STAC recommends that single band assets should only use the <code>bands</code> array in the following cases:</p> <ol> <li>It's important in to convey that a band is present in the asset.</li> <li>This is the case if the data access mechanism requires you to specify the name of index of the band to retrieve the data,      then the band should be specified as such.</li> <li>This is also the case if the band has a specific name.      The <code>name</code> property is only available under the <code>bands</code> array and as such can't be specified for the Asset.</li> <li>It is important that the (often spectral) band is part of a set of bands.</li> <li>For example, if the <code>bands</code> array is exposed in the Collection Summaries,      then a <code>bands</code> array should be defined in the Items or Item Assets as otherwise there's nothing to summarize.</li> <li>Individual bands are repeated in different assets.</li> <li>This may happen if you provide assets with different resolutions or file formats.      The <code>name</code> property with the same value should be used so that users can identify that the bands are the same.      It also enables clients to easily combine and summarize the bands.</li> </ol>"},{"location":"best-practices/#multiple-bands","title":"Multiple bands","text":"<p>Generally, all properties that have the same value across all bands should not be listed in the <code>bands</code> array but in the assets directly.</p> <p>For example, if your <code>bands</code> array in an asset is defined as follows:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"bands\": [\n        {\n          \"name\": \"r\",\n          \"eo:common_name\": \"red\",\n          \"data_type\": \"uint16\",\n          \"raster:spatial_resolution\": 10\n        },\n        {\n          \"name\": \"g\",\n          \"eo:common_name\": \"green\",\n          \"data_type\": \"uint16\",\n          \"raster:spatial_resolution\": 10\n        },\n        {\n          \"name\": \"b\",\n          \"eo:common_name\": \"blue\",\n          \"data_type\": \"uint16\",\n          \"raster:spatial_resolution\": 10\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The <code>data_type</code> and <code>raster:spatial_resolution</code> has the same value for all bands. As such you can deduplicate those properties and list them in the asset directly:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"data_type\": \"uint16\",\n      \"raster:spatial_resolution\": 10,\n      \"bands\": [\n        {\n          \"name\": \"r\",\n          \"eo:common_name\": \"red\"\n        },\n        {\n          \"name\": \"g\",\n          \"eo:common_name\": \"green\"\n        },\n        {\n          \"name\": \"b\",\n          \"eo:common_name\": \"blue\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"best-practices/#band-migration","title":"Band migration","text":"<p>It should be relatively simple to migrate from STAC 1.0 (i.e. <code>eo:bands</code> and/or <code>raster:bands</code>) to the new <code>bands</code> array.</p> <p>Usually, you can simply merge each object on a by-index basis. Nevertheless, you should consider deduplicating properties with the same values across all bands to the Asset. For some fields, you need to add the extension prefix of the <code>eo</code> or <code>raster</code> extension to the property name.</p> <p>STAC 1.0 example:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"eo:bands\": [\n        {\n          \"name\": \"r\",\n          \"common_name\": \"red\"\n        },\n        {\n          \"name\": \"g\",\n          \"common_name\": \"green\"\n        },\n        {\n          \"name\": \"b\",\n          \"common_name\": \"blue\"\n        },\n        {\n          \"name\": \"nir\",\n          \"common_name\": \"nir\"\n        }\n      ],\n      \"raster:bands\": [\n        {\n          \"data_type\": \"uint16\",\n          \"spatial_resolution\": 10,\n          \"sampling\": \"area\"\n        },\n        {\n          \"data_type\": \"uint16\",\n          \"spatial_resolution\": 10,\n          \"sampling\": \"area\"\n        },\n        {\n          \"data_type\": \"uint16\",\n          \"spatial_resolution\": 10,\n          \"sampling\": \"area\"\n        },\n        {\n          \"data_type\": \"uint16\",\n          \"spatial_resolution\": 30,\n          \"sampling\": \"area\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>After migrating to STAC 1.1 this is ideally provided as follows:</p> <pre><code>{\n  \"assets\": {\n    \"example\": {\n      \"href\": \"example.tif\",\n      \"data_type\": \"uint16\",\n      \"raster:sampling\": \"area\",\n      \"raster:spatial_resolution\": 10,\n      \"bands\": [\n        {\n          \"name\": \"r\",\n          \"eo:common_name\": \"red\"\n        },\n        {\n          \"name\": \"g\",\n          \"eo:common_name\": \"green\"\n        },\n        {\n          \"name\": \"b\",\n          \"eo:common_name\": \"blue\"\n        },\n        {\n          \"name\": \"nir\",\n          \"eo:common_name\": \"nir\",\n          \"raster:spatial_resolution\": 30\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>The following was done:</p> <ul> <li>The arrays have been merged into a single property <code>bands</code>.</li> <li>The properties <code>common_name</code> and <code>spatial_resolution</code> were renamed to include the extension prefixes.</li> <li>The properties <code>data_type</code> and <code>raster:sampling</code> (renamed from <code>sampling</code>) were deduplicated to the Asset   as the values were the same across all bands.</li> <li>The <code>spatial_resolution</code> was also deduplicated, i.e. <code>10</code> is provided on the asset level,   which is inherited by the bands unless explicitly overridden.   Therefore, the <code>nir</code> band overrides the value <code>10</code> with a value of <code>30</code>.</li> </ul> <p>As a result, the new <code>bands</code> array is more lightweight and easier to handle.</p>"},{"location":"best-practices/#catalog-collection-practices","title":"Catalog &amp; Collection Practices","text":"<p>Note: This section uses the term 'Catalog' (with an uppercase C) to refer to the JSON entity specified in the  Catalog spec, and 'catalog' (with a lowercase c) to refer to any full STAC implementation,  which can be any mix of Catalogs, Collections, and Items.</p>"},{"location":"best-practices/#static-and-dynamic-catalogs","title":"Static and Dynamic Catalogs","text":"<p>As mentioned in the main overview, there are two main types of catalogs - static and dynamic. This section explains each of them in more depth and shares some best practices on each.</p>"},{"location":"best-practices/#static-catalogs","title":"Static Catalogs","text":"<p>A static catalog is an implementation of the STAC specification that does not respond dynamically to requests. It is simply a set of files on a web server that link to one another in a way that can be crawled, often stored in an cloud storage service like Amazon S3, Azure Storage and Google Cloud Storage. But any http server could expose a static catalog as files. The core JSON documents and link structures are encoded in the file, and work as long as things are structured properly. A static catalog can only really be crawled by search engines and active catalogs; it can not respond to queries. But it is incredibly reliable, as there are no moving parts, no clusters or databases to maintain. The goal of STAC is to expose as much asset metadata online as possible, so the static catalog offers a very low barrier to entry for anyone with geospatial assets to make their data searchable.</p> <p>Static catalogs tend to make extensive use of sub-catalogs to organize their Items into sensible browsing structures,  as they can only have a single representation of their catalog, since the static nature means the structure is baked in. While it is up to the implementor to organize the catalog, it is recommended to arrange it in a way that would make sense  for a human to browse a set of STAC Items in an intuitive matter.</p> <p>Users indicate their intent for a file to be parsed as a Collection or Catalog using the required <code>type</code> field on each entity. For Collections, this field must have the value <code>Collection</code>, while for Catalogs, it must have the value <code>Catalog</code>. Additionally, we recommend for static STACs indicate contents using the filenames <code>catalog.json</code> or <code>collection.json</code> to distinguish the Catalog from other JSON type files. In order to support multiple catalogs, the recommended practice  is to place the Catalog file in namespaces \"directories\". For example:</p> <ul> <li>current/catalog.json</li> <li>archive/catalog.json</li> </ul>"},{"location":"best-practices/#dynamic-catalogs","title":"Dynamic Catalogs","text":"<p>A dynamic catalog is implemented in software as an HTTP-based API, following the same specified JSON structure for Items, Catalogs and Collections. Its structure and responses are usually generated dynamically, instead of relying on a set of already defined files. But the result is the same, enabling the same discovery from people browsing and search engines crawling.  It generally indexes data for efficient responses, and aims to be easy for existing APIs to implement as a more standard interface  for clients to consume. A dynamic catalog will sometimes be populated by a static catalog, or at least may have a 'backup' of its  fields stored as a cached static catalog.</p> <p>Dynamic catalogs often also implement the STAC API specification, that  responds to search queries (like \"give me all imagery in Oahu gathered on January 15, 2017\"). But they are not required to.  One can have a dynamic service that only implements the core STAC specification, and is crawled by STAC API implementations that provide 'search'. For example a Content Management Service like Drupal or an open data catalog like CKAN could choose to expose  its content as linked STAC Items by implementing a dynamic catalog. </p> <p>One benefit of a dynamic catalog is that it can generate various 'views' of the catalog, exposing the same Items in  different sub-catalog organization structures. For example one catalog could divide sub-catalogs by date and another by providers, and users could browse down to both. The leaf Items should just be linked to in a single canonical location (or at least use a <code>rel</code> link that indicates the location of the canonical one).</p>"},{"location":"best-practices/#catalog-layout","title":"Catalog Layout","text":"<p>Creating a catalog involves a number of decisions as to what folder structure to use to represent sub-catalogs, Items and assets, and how to name them. The specification leaves this totally open, and you can link things as you want. But  it is recommended to be thoughtful about the organization of sub-catalogs, putting them into a structure that a person might reasonably browse (since they likely will with STAC on the Web recommendations). For example start with location, like a normal grid (path+row in Landsat) or administrative boundaries (country -&gt; state-level) and  then year, month, day. Or do the opposite - date and then location. Making a huge unordered list is technically allowed, but not helpful for discovery of data. Thus it is generally considered a best practice to make use of sub-catalogs to  keep the size of each sub-catalog under a megabyte. If your sub-catalog lists tens of thousands of child items then you should consider an additional way to break it up. </p> <p>We encourage people to explore new structures of linking data, but the following list is what a number of implementors  ended up doing. Following these recommendations makes for more legible catalogs, and many tools operate more efficiently if you follow these recommendations.</p> <ol> <li>Root documents (Catalogs / Collections) should be at the root of a directory tree containing the static catalog.</li> <li>Catalogs should be named <code>catalog.json</code> and Collections should be named <code>collection.json</code>.</li> <li>Items should be named <code>&lt;id&gt;.json</code>.</li> <li>Sub-Catalogs or sub-Collections should be stored in subdirectories of their parent    (and only 1 subdirectory deeper than a document's parent, e.g. <code>.../sample/sub1/catalog.json</code>).</li> <li>Items should be stored in subdirectories of their parent Catalog or Collection    if there are usually sidecar files stored alongside the Item.    This means that each Item and its assets are contained in a unique subdirectory unless this would regularly lead to a single Item in a directory.</li> <li>Limit the number of Items in a Catalog or Collection, grouping / partitioning as relevant to the dataset.</li> <li>Use structural elements (Catalog and Collection) consistently across each 'level' of your hierarchy.    For example, if levels 2 and 4 of the hierarchy only contain Collections,    don't add a Catalog at levels 2 and 4.</li> </ol> <p>One further recommendation to help tools is to always include the 'title' field when including a link, especially in the  <code>item</code>, <code>child</code>, <code>parent</code> and <code>root</code> links, even if it repeats several times. This should be the same as the 'title' in the  link destination. Having this enables clients to display a nice human readable name of the link without having  to open the  link destination. </p>"},{"location":"best-practices/#dynamic-catalog-layout","title":"Dynamic Catalog Layout","text":"<p>While these recommendations were primarily written for static catalogs, they apply equally well to dynamic catalogs. Subdirectories of course would just be URL paths  generated dynamically, but the structure would be the same as is recommended.</p> <p>One benefit of a dynamic catalog is that it can generate various 'views' of the catalog, exposing the same Items in  different sub-catalog organization structures. For example one catalog could divide sub-catalogs by date and another  by providers, and users could browse down to both. The leaf Items should just be linked to in a single canonical location  (or at least use a rel link that indicates the location of the canonical one). It is recommended that dynamic catalogs  provide multiple 'views' to allow users to navigate in a way that makes sense to them, providing multiple 'sub-catalogs' from the root that enable different paths to browse (country/state, date/time, constellation/satellite, etc). But the  canonical 'rel' link should be used to designate the primary location of the Item to search engine crawlers.</p>"},{"location":"best-practices/#mixing-stac-versions","title":"Mixing STAC Versions","text":"<p>Although it is allowed to mix STAC versions, it should be used carefully as clients may not support all versions so that  the catalog could be of limited use to users. A Catalog or Collection linking to differently versioned Sub-Catalogs or Sub-Collections is a common use case when multiple data source are combined. Client developers should be aware of this use case. Nevertheless, it  is strongly recommended that Catalogs don't contain differently versioned Items so that users/clients can at least use and/or download consistent (Sub-)Catalogs containing either all or no data. Collections that are referenced from Items should always use the same STAC version. Otherwise some behaviour of functionality may be unpredictable (e.g. merging common fields into Items or reading summaries).</p>"},{"location":"best-practices/#using-summaries-in-collections","title":"Using Summaries in Collections","text":"<p>One of the strongest recommendations for STAC is to always provide summaries in your Collections. The core team decided to not require them, in case there are future situations where providing a summary is too difficult. The idea behind them is not to exhaustively summarize every single field in the Collection, but to provide a bit of a 'curated' view. </p> <p>Some general thinking on what to summarize is as follows:</p> <ul> <li> <p>Any field that is a range of data (like numbers or dates) is a great candidate to summarize, to give people a sense what values the data might be. For example in overhead imagery, a  <code>view:off_nadir</code> with a range of 0 to 3 would tell people this imagery is all pretty much straight down, while a value of 15 to 40 would tell them that it's oblique imagery, or 0 to 60 that it's  a Collection with lots of different look angles. </p> </li> <li> <p>Fields that have only one or a handful of values are also great to summarize. Collections with a single satellite may use a single <code>gsd</code> field in the summary, and it's quite useful for users to know that all data is going to be the same resolution. Similarly it's useful to know the names of all the  <code>platform</code> values that are used in the Collection. </p> </li> <li> <p>It is less useful to summarize fields that have numerous different discrete values that can't easily be represented in a range. These will mostly be string values, when there aren't just a handful of options. For example if you had a  'location' field that gave 3 levels of administrative region (like 'San Francisco, California, United States') to help people understand more intuitively where a shot was taken. If your Collection has millions of Items, or even hundreds, you don't want to include all the different location string values in a summary. </p> </li> <li> <p>Fields that consist of arrays are more of a judgement call. For example <code>instruments</code> is straightforward and recommended, as the elements of the array are a discrete set of options. On the other hand  <code>proj:transform</code> makes no sense to summarize, as the union of all the values in the array are meaningless, as each Item is describing its transform, so combining them would just be a bunch of random numbers. So if the values contained in the array are independently meaningful (not interconnected) and there aren't hundreds of potential values then it is likely a good candidate to summarize.</p> </li> </ul> <p>We do highly recommend including a <code>bands</code> summary if your Items implement <code>bands</code>,  especially if it represents just one satellite or constellation. This should be a union of all the potential bands that you  have in assets. It is ok to only add the summary at the Collection level without putting <code>bands</code> at the  <code>properties</code> level of an Item. This gives users of the Collection a sense of the sensor capabilities without  having to examine specific Items or aggregate across every Item.</p> <p>Note that the ranges of summaries don't have to be exact. If you are publishing a catalog that is constantly updating with data from a high agility satellite you can put the <code>view:off_nadir</code> range to be the expected values, based on the satellite design, instead of having it only represent the off nadir angles that are Items for assets already captured in the catalog. We don't want growing catalogs to have to constantly check and recalculate their summaries whenever new data comes in - its just meant to give users a sense of what types of values they could expect. </p>"},{"location":"best-practices/#use-of-links","title":"Use of links","text":"<p>The STAC specifications allow both relative and absolute links, and it is important to choose the correct link types so that your STAC catalogs are easy to explore and resilient to any future changes to their layouts. The best practice is to use one of the below catalog types, applying the link recommendations consistently, instead of just haphazardly applying relative links in some places and absolute ones in other places.</p>"},{"location":"best-practices/#self-contained-catalogs","title":"Self-contained Catalogs","text":"<p>A 'self-contained catalog' is one that is designed for portability. Users may want to download a catalog from online and be able to use it on their local computer, so all links need to be relative. Or a tool that creates catalogs may need to work  without knowing the final location that it will live at online, so it isn't possible to set absolute 'self' URL's. These use cases should utilize a catalog that follows the listed principles:</p> <ul> <li> <p>Only relative href's in structural <code>links</code>: The full catalog structure of links down to sub-catalogs and Items, and their  links back to their parents and roots, should be done with relative URL's. The structural rel types include <code>root</code>, <code>parent</code>,  <code>child</code>, <code>item</code>, and <code>collection</code>. Other links can be absolute, especially if they describe a resource that makes less sense in the catalog, like sci:doi,  <code>derived_from</code> or even <code>license</code> (it can be nice to include the license in the catalog, but some licenses live at a canonical  online location which makes more sense to refer to directly). This enables the full catalog to be downloaded or copied to another location and to still be valid. This also implies no <code>self</code> link, as that link must be absolute.</p> </li> <li> <p>Use Asset <code>href</code> links consistently: The links to the actual assets are allowed to be either relative or absolute. There are two types of 'self-contained catalogs'. </p> </li> </ul>"},{"location":"best-practices/#self-contained-metadata-only","title":"Self-contained Metadata Only","text":"<p>These consist of just the STAC metadata (Collection, Catalog and Item files), and uses absolute href  links to refer to the online locations of the assets. </p>"},{"location":"best-practices/#self-contained-with-assets","title":"Self-contained with Assets","text":"<p>These use relative href links for the assets, and includes them in the folder structure. This enables offline use of a catalog, by including all the actual data, referenced locally.</p> <p>Self-contained catalogs tend to be used more as static catalogs, where they can be easily passed around. But often they will be generated by a more dynamic STAC service, enabling a subset of a catalog or a portion of a search criteria to be downloaded and used in other contexts. That catalog could be used offline, or even published in another location.</p> <p>Self-contained catalogs are not just for offline use, however - they are designed to be able to be published online and to live on the cloud in object storage. They just aim to ease the burden of publishing, by not requiring lots of updating of links.  Adding a single <code>self</code> link at the root is recommended for online catalogs, turning it into a 'relative published catalog', as detailed below. This anchors it in an online location and enables provenance tracking.</p>"},{"location":"best-practices/#published-catalogs","title":"Published Catalogs","text":"<p>While STAC is useful as a portable format to move between systems, the goal is really to enable search. While any combination of absolute and relative links is technically allowed by the specification, it is strongly recommended to follow one of the  patterns described below when publishing online. Many clients will not properly handle arbitrary mixes of absolute and relative href's. </p> <p>We refer to a 'published catalog' as one that lives online in a stable location, and uses <code>self</code> links to establish its location and  enable easy provenance tracking. There are two types of published catalogs:</p>"},{"location":"best-practices/#absolute-published-catalog","title":"Absolute Published Catalog","text":"<p>This is a catalog that uses absolute links for everything, both in the <code>links</code> objects and in the <code>asset</code> hrefs. It includes <code>self</code> links for every Item. Generally these are implemented by dynamic catalogs, as it is quite easy for them to generate the proper links dynamically. But a static catalog that knows its published location could easily implement it.</p>"},{"location":"best-practices/#relative-published-catalog","title":"Relative Published Catalog","text":"<p>This is a self-contained catalog as described above, except it includes an absolute <code>self</code> link at the root to identify its online location. This is designed so that a self-contained catalog (of either type, with its  assets or just metadata) can be 'published' online by just adding one field (the self link) to its root (Catalog or Collection). All the other links should remain the same. The resulting catalog is no longer compliant with the self-contained catalog recommendations, but instead transforms into a 'relative published catalog'.  With this, a client may resolve Item and sub-catalog self links by traversing parent and root links, but requires reading  multiple sources to achieve this. </p> <p>So if you are writing a STAC client it is recommended to start with just supporting these two types of published catalogs. In  turn, if your data is published online publicly or for use on an intranet then following these recommendations will ensure that a wider range of clients will work with it.</p>"},{"location":"best-practices/#using-relation-types","title":"Using Relation Types","text":"<p>Implementors of STAC are highly recommended to be quite liberal with their <code>links</code>, and to use the <code>rel</code> field (in conjunction with the <code>type</code> field) to communicate the structure and content of related entities. While each STAC spec describes some of the  'custom' relations STAC has set, the ideal is to reuse official IANA Link Relation  Types as much as possible. The following table describes a number of the common official relations that are used in production STAC implementations.</p> Type Description alternate It is recommended that STAC Items are also available as HTML, and should use this rel with <code>\"type\" : \"text/html\"</code> to tell clients where they can get a version of the Item or Collection to view in a browser. See STAC on the Web in Best Practices for more information. canonical The URL of the canonical version of the Item or Collection. API responses and copies of catalogs should use this to inform users that they are direct copy of another STAC Item, using the canonical rel to refer back to the primary location. via The URL of the source metadata that this STAC Item or Collection is created from. Used similarly to canonical, but refers back to a non-STAC record (Landsat MTL, Sentinel metadata XML, etc) prev Indicates that the link's context is a part of a series, and that the previous in the series is the link target. Typically used in STAC by API's, to return smaller groups of Items or Catalogs/Collections. next Indicates that the link's context is a part of a series, and that the next in the series is the link target. Typically used in STAC by API's, to return smaller groups of Items or Catalogs/Collections. preview Refers to a resource that serves as a preview (see RFC 6903, sec. 3), usually a lower resolution thumbnail. In STAC this would usually be the same URL as the thumbnail asset, but adding it as a link in addition enables OGC API clients that can't read assets to make use of it. It also adds support for thumbnails to STAC Catalogs as they can't list assets. derived_from URL to a STAC Entity that was used as input data in the creation of this Entity. <p>Being liberal with the <code>links</code> also means that it's ok to have repeated links with the same <code>href</code>. For example the <code>parent</code> and <code>root</code> relation types will point at the same file when the child is directly below the root, and it is recommended to include both. </p>"},{"location":"best-practices/#derived-from-relation-derived_from","title":"Derived from relation (<code>derived_from</code>)","text":"<p>A full provenance model is far beyond the scope of STAC, and the goal is to align with any good independent spec that comes along for that. But the <code>derived_from</code> field is seen as a way to encourage fuller specs and at least start a linking structure that can be used as a jumping off point for more experiments in provenance tracking.</p>"},{"location":"best-practices/#versioning-for-catalogs","title":"Versioning for Catalogs","text":"<p>In the Item and Collection STAC JSON, versions and deprecation can be indicated with the Versioning Indicators Extension.</p> <p>The Items and Collections API Version Extension provides endpoints and  semantics for keeping and accessing previous versions of Collections and Items. The same semantics can be used in static  catalogs to preserve previous versions of the documents and link them together.</p> <p>In order to achieve this, the static catalog must make sure that for every record created, a copy of the record is also  created in a separate location and it is named with the version id adopted by the catalog. See  here for recommendations on versioning schema.</p> <p>The main record should also provide a link to the versioned record following the linking patterns described  here. For every update to the record, the same  cycle is repeated:</p> <ol> <li>Add link from the updated record to the previous version</li> <li>Create a copy of the updated record and name it correctly</li> </ol>"},{"location":"best-practices/#example","title":"Example","text":"<p>When the record <code>my_item.json</code> is created, a copy of it is also created. <code>my_item.json</code> includes <code>permalink</code> to <code>my_item_01.json</code>. The version suffix of the file name is taken from the version field of the record when it is available.</p> <ul> <li><code>root / collections / example_collection / items / my_item / my_item.json</code></li> <li><code>root / collections / example_collection / items / my_item / my_item_01.json</code></li> </ul> <p>When <code>my_item.json</code> is updated, the new <code>my_item.json</code> includes a link to <code>my_item_01.json</code> and is also copied to <code>my_item_02.json</code>. This ensures that <code>my_item_02.json</code> includes a link to <code>my_item_01.json</code></p> <ul> <li><code>root / collections / example_collection / items / my_item / my_item.json</code></li> <li><code>root / collections / example_collection / items / my_item / my_item_01.json</code></li> <li><code>root / collections / example_collection / items / my_item / my_item_02.json</code></li> </ul>"},{"location":"best-practices/#static-to-dynamic-best-practices","title":"Static to Dynamic best practices","text":"<p>Many implementors are using static catalogs to be the reliable core of their dynamic services, or layering their STAC API on top of any static catalog that is published. These are some recommendations on how to handle this:</p>"},{"location":"best-practices/#ingestion-and-links","title":"Ingestion and links","text":"<p>Implementors have found that it's best to 'ingest' a static STAC into an internal datastore (often elasticsearch, but a  traditional database could work fine too) and then generate the full STAC API responses from that internal representation. There are instances that have the API refer directly to the static STAC Items, but this only works well if the static STAC  catalog is an 'absolute published catalog'. So the recommendation is to always use absolute links - either in the static  published catalog, or to create new absolute links for the STAC search/ endpoint  responses, with the API's location at the base url. The <code>/</code> endpoint with the catalog could either link directly to the static catalog, or can follow the 'dynamic catalog layout' recommendations above with a new set of URL's.</p> <p>Ideally each Item would use its <code>links</code> to provide a reference back to the static location. The location of the static Item should be treated as the canonical location, as the generated API is more likely to move or be temporarily down. The spec provides the <code>derived_from</code> rel field, which fits well enough, but <code>canonical</code> is likely the more appropriate one as everything but the links should be the same.</p>"},{"location":"best-practices/#keep-catalogs-in-sync-with-cloud-notification-and-queue-services","title":"Keep catalogs in sync with cloud notification and queue services","text":"<p>There is a set of emerging practices to use services like Amazon's Simple Queue Service (SQS) and Simple Notification Service (SNS) to keep catalogs in sync. There is a great blog post on the CBERS STAC implementation on AWS. The core idea is that a static catalog should emit a notification whenever it changes. The recommendation for SNS is to use the STAC  Item JSON as the message body, with some fields such as a scene\u2019s datetime and geographic bounding box that allows  basic geographic filtering from listeners. </p> <p>The dynamic STAC API would then listen to the notifications and update its internal datastore whenever new data comes into the static catalog. Implementors have had success using AWS Lambda to do a full 'serverless' updating of the elasticsearch database, but it could just as easily be a server-based process.</p>"},{"location":"best-practices/#how-to-differentiate-stac-files","title":"How to Differentiate STAC Files","text":"<p>Any tool that crawls a STAC implementation or encounters a STAC file in the wild needs a clear way to determine if it is an Item,  Collection or Catalog. As of 1.0.0 this is done primarily with the <code>type</code> field, and secondarily in Items with <code>stac_version</code>, or optionally with the <code>rel</code> of the link to it.</p> <pre><code>if type is 'Collection'\n  =&gt; Collection\nelse if type is 'Catalog'\n  =&gt; Catalog\nelse if type is 'Feature' and stac_version is defined\n  =&gt; Item\nelse\n  =&gt; Invalid (JSON)\n</code></pre> <p>When crawling a STAC implementation, one can also make use of the relation type (<code>rel</code> field) when following a link. If it is an <code>item</code> rel type then the file must be a STAC Item. If it is <code>child</code>, <code>parent</code> or <code>root</code> then it must be a Catalog or a Collection, though the final determination between the two requires looking at the <code>type</code> field in the Catalog or Collection JSON that it is linked to. Note that there is also a <code>type</code> field in STAC Link and Asset objects, but that is for the Media Type, but there are not specific media types for Catalog and Collection. See the sections on STAC media types, and Asset media types for more information.</p> <p>In versions of STAC prior to 1.0 the process was a bit more complicated, as there was no <code>type</code> field for catalogs and collections. See this issue comment for a heuristic that works for older STAC versions.</p>"},{"location":"overview/","title":"STAC Overview","text":"<p>There are three component specifications that together make up the core SpatioTemporal Asset Catalog specification. Each can be used alone, but they work best in concert with one another. The STAC API specification  builds on top of that core, but is out of scope for this overview. An Item represents a  single spatiotemporal asset as GeoJSON so it can be searched.  The Catalog specification provides structural elements, to group Items and Collections. Collections are catalogs, that add more required metadata and  describe a group of related Items. For more on the differences see the section below.</p> <p>A UML diagram of the STAC model is also  provided to help with navigating the specification. </p>"},{"location":"overview/#foundations","title":"Foundations","text":"<p>STAC is built on top of many great standards and practices. Every part of STAC is  JSON, and GeoJSON provides the core geometry fields  and features definition. All fields are described in the  specifications, and the acceptable values are defined with JSON Schema. The released JSON Schemas provide the core testing definitions, and are used in an array of validation tools. We also rely on RFC 8288 (Web Linking) to express relationships between resources, and IANA Media Types to describe file formats and format contents. The OGC API - Features standard is a final core building block. The STAC Collection extends the Collection JSON defined in OGC API - Features (and the full API definition is the foundation for the STAC API specification).</p> <p>The STAC specifications are written to be understandable without needing a full background in these. But if you  want to get deep into STAC tool implementation and are not familiar with any of the standards mentioned above it is  recommended to read up on them. STAC development is guided by set of core philosophical tenets, like  building small reusable parts that are loosely coupled, focusing on developers, and more - see our the  principles document to learn more.</p> <p>Note: Setting a field in JSON to <code>null</code> is not equivalent to a field not appearing in STAC, as JSON Schema tools treat them differently. STAC defines <code>null</code> explicitly for some fields, where it has a particular meaning. So <code>null</code> should  not be used unless the STAC spec defines its use - instead the field should be left out entirely. </p>"},{"location":"overview/#item-overview","title":"Item Overview","text":"<p>Fundamental to any SpatioTemporal Asset Catalog, an Item object represents a unit of data and metadata, typically representing a single scene of data at one place and time.   A STAC Item is a  GeoJSON Feature and can be easily read by any modern GIS or geospatial library, and it describes a  SpatioTemporal Asset.  The STAC Item JSON specification uses the GeoJSON geometry to describe the location of the asset, and  then includes additional information:</p> <ul> <li>the time the asset represents;</li> <li>a thumbnail for quick browsing;</li> <li>asset links, to enable direct download or streaming access of the asset;</li> <li>relationship links, allowing users to traverse other related resources and STAC Items.</li> </ul> <p>A STAC Item can contain additional fields and JSON structures to communicate more information about the asset, so it can be easily searched. STAC provides a core set of  Common Metadata and there is a wider community working on a variety of STAC Extensions that provide shared metadata for  more specific domains. Both aim to describe data with well known, well defined terms to enable consistent publishing and better search. For more recommendations on selecting fields for an Item see this section of the best practices document.</p>"},{"location":"overview/#what-is-a-spatiotemporal-asset","title":"What is a SpatioTemporal Asset","text":"<p>A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain  space and time. Examples include Imagery (from satellites, planes and drones), SAR, Point Clouds (from LiDAR, Structure from Motion, etc), Data Cubes, Full Motion Video, and data derived from any of those. The key is that the GeoJSON is not the actual 'thing', but instead references files and serves as an index to the 'assets'. It is not recommended  to use STAC to refer to traditional vector data layers (shapefile, geopackage) as assets, as they don't quite fit conceptually. </p>"},{"location":"overview/#catalogs-vs-collections","title":"Catalogs vs Collections","text":"<p>Before we go deep into the Catalogs and Collections, it is worth explaining the relationship  between the two and when you might want to use one or the other. </p> <p>A Catalog is a very simple construct - it just provides links to Items or to other Catalogs.  The closest analog is a folder in a file structure, it is the container for Items, but it can  also hold other containers (folders / catalogs). </p> <p>The Collection entity shares most fields with the Catalog entity but has a number of additional fields: license, extent (spatial and temporal), providers, keywords and summaries. Every Item in a Collection links back to their Collection, so clients can easily find fields like the license. Thus every Item implicitly  shares the fields described in their parent Collection. Collection entities can be used just like Catalog  entities to provide structure, as they provide all the same options for linking and organizing.</p> <p>But what should go in a Collection, versus just in a Catalog?  A Collection will generally consist of a set of assets that are defined with the same properties and share higher level metadata. In the  satellite world these would typically all come from the same sensor or constellation. It corresponds directly to what others call a \"dataset series\" (ESA, ISO 19115), \"collection\" (CNES, NASA), and  \"dataset\" (JAXA, DCAT). So if all your Items have the same properties, they probably belong in  the same Collection. But the construct is deliberately flexible, as there may be good reasons to break the recommendation.</p> <p>Catalogs in turn are used for two main things:</p> <ul> <li>Split overly large collections into groups</li> <li>Group collections into a catalog of Collections (e.g. as entry point for navigation to several Collections).</li> </ul> <p>The first case allows users to browse down into the Items of large collections. A collection like Landsat usually would start with path and row Catalogs to group by geography, and then year,  month and day groups to enable deeper grouping. Dynamic catalogs can provide multiple grouping paths, serving as a sort of faceted search.</p> <p>The second case is used when one wants to represent diverse data in a single place. If an organization has an internal catalog with Landsat 8, Sentinel 2, NAIP data and several commercial imagery providers then they'd have a root Catalog that would link to a number of different Collections. </p> <p>So in conclusion it's best to use Collections for what you want users to find as the starting point, and then Catalogs are just for structuring and grouping the data. Future work includes a mechanism to actually search Collection-level data, hopefully in concert with other specifications.</p>"},{"location":"overview/#catalog-overview","title":"Catalog Overview","text":"<p>NOTE: The below examples all say Catalog, but those can all be Collections as well, as it has all the fields necessary to  serve as a Catalog</p> <p>There are two required element types of a Catalog: Catalog and Item. A STAC Catalog points to STAC Items, or to other STAC catalogs. It provides a simple linking structure that can be used recursively so that many Items can be included in  a single Catalog, organized however the implementor desires. </p> <p>STAC makes no formal distinction between a \"root\" Catalog and the \"child\" Catalogs. A root Catalog is simply the top-most Catalog or Collection -- it has no parent. A nested catalog structure is useful (and recommended) for breaking up massive numbers of catalog Items into logical groupings. For example, it might make sense to organize a catalog by date (year, month, day), or geography (continent, country, state/prov). See the Catalog Layout best practices section for more.</p> <p>A simple STAC structure might look like this:</p> <ul> <li>catalog (root)</li> <li>catalog<ul> <li>catalog</li> <li>item<ul> <li>asset</li> </ul> </li> <li>item<ul> <li>asset</li> </ul> </li> <li>item</li> <li>asset</li> <li>asset</li> </ul> </li> </ul> <p>This example might be considered a somewhat \"typical\" structure. However, Catalogs and Items can describe a number of different relationships. The following shows various relationships between catalogs and items:</p> <ul> <li><code>Catalog</code> -&gt; <code>Item</code> (this is a common structure for a catalog to list links to Items)</li> <li><code>Catalog</code> -&gt; <code>Catalog</code> (this is a common tree structure to group sets of Items. Each catalog in   this relationship may also include Item links as well as catalog links)</li> </ul> <p>The relationships are all described by a common <code>links</code> object structure, making use of the <code>rel</code> field to further describe the relationship. </p> <p>There are a few types of catalogs that implementors occasionally refer to. These get defined by the <code>links</code> structure.</p> <ul> <li>A sub-catalog is a Catalog that is linked to from another Catalog that is used to better organize data. For example a Landsat collection   might have sub-catalogs for each Path and Row, so as to create a nice tree structure for users to follow.</li> <li>A root catalog is a Catalog that only links to sub-catalogs. These are typically entry points for browsing data. Often   they will contain the STAC Collection definition, but in implementations that publish diverse information it may   contain sub-catalogs that provide a variety of Collections.</li> <li>A parent catalog is the Catalog that sits directly above a sub-catalog. Following parent catalog links continuously   will naturally end up at a root catalog definition.</li> </ul> <p>It should be noted that a Catalog does not have to link back to all the other Catalogs that point to it. Thus a published  root catalog might be a sub-catalog of someone else's structure. The goal is for data providers to publish all the  information and links they want to, while also encouraging a natural web of information to arise as Catalogs and Items are linked to across the web.</p>"},{"location":"overview/#static-and-dynamic-catalogs","title":"Static and Dynamic Catalogs","text":"<p>The Catalog specification is designed so it can be implemented as easily as possible. This can be as simple as simply putting linked json files on a file server or an object storage service (like AWS S3), or it can be generated on the fly by a live server. The first type of implementation is often called a 'static catalog', and any catalog that is not just files is called a 'dynamic catalog'. You can read more about the two types along with recommendations in this section of the best practices document,  along with how to keep a dynamic catalog in sync with a static one.</p>"},{"location":"overview/#catalog-best-practices","title":"Catalog Best Practices","text":"<p>In addition to information about different catalog types, the best practices document has a number of suggestions on how to organize and implement good catalogs. The catalog specification is designed for maximum flexibility, so none of these are required, but they provide guidance for implementors who want to follow what most of the STAC community is doing.</p> <ul> <li>Catalog Layout is likely the most important section, as following its  recommendations will enable catalogs to work better with client tooling that optimizes for known layouts.</li> <li>Use of Links articulates practices for making catalogs that are portable (with relative links through out) and ones that are published in stable locations (with absolute self links).</li> <li>Versioning for Catalogs explains how to use STAC's structure to keep a history of changes made to Items and catalogs.</li> <li>STAC on the Web explains how catalogs should have html versions for  each Item and Catalog, as well as ways to achieve that.</li> </ul>"},{"location":"overview/#collection-overview","title":"Collection Overview","text":"<p>A STAC Collection includes the core fields of the Catalog entity and also provides additional metadata to describe  the set of Items it contains. The required fields are fairly  minimal - it includes the 4 required Catalog fields (id, description, stac_version and links), and adds license  and extents. But there are a number of other common fields defined in the spec, and more common fields are also  defined in STAC extensions. These serve as basic metadata, and ideally Collections also link to  fuller metadata (ISO 19115, etc) when it is available.</p> <p>As Collections contain all of Catalogs' core fields, they can be used just as flexibly. They can have both parent Catalogs and Collections as well as child Items, Catalogs and Collections. Items are strongly recommended to have a link to the Collection they are a part of. Items can only belong to one Collection, so if an Item is in a Collection that is the child of  another Collection, then it must pick which one to refer to. Generally the 'closer' Collection, the more specific one, should be the one linked to.</p> <p>The Collection specification is used standalone quite easily - it is used to describe an aggregation of data,  and doesn't require links down to sub-catalogs and Items. This is most often used when the software does operations at the layer / coverage level, letting users manipulate a whole collection of assets at once. They often have an optimized internal format that doesn't make sense to expose as Items. OpenEO and  Google Earth Engine are two examples that only use STAC collections, and both would be hard-pressed to expose individual Items due to their architectures. For others implementing STAC Collections can also be a nice way to start and achieve some level of interoperability. </p>"},{"location":"principles/","title":"Principles","text":"<p>This project will be governed by a set of informal core principles. These principles are not set in stone, and indeed they should evolve in the same manner that all specifications worked on should - proposed and reviewed in pull requests, approved by consensus. The goal of the principles is to help avoid bikeshedding - lay down some meta-rules so we can focus on creating useful core geospatial standards.</p> <ul> <li>Creation and evolution of specs in Github, using Open Source principles   (please read Producing OSS if that phrase doesn't immediately make sense to you).   The collaboration facilities of Github should be used to their full extent. All proposed improvements and   changes should come in the form of pull requests, using code review functionality to discuss changes.</li> <li>JSON + REST + HTTP at the core. JSON has won over XML, and REST over SOAP. We embrace them and   are not considering legacy options. Forward looking protocols can be considered as extensions,   but the default specifications should be in JSON, following best REST practices. HTTP caching and   error codes should be leveraged at the core. GeoJSON has already defined the core geospatial JSON response,   so it should also be core.</li> </ul> <p>OGC APIs (especially Common, Features, and Records)   and/or JSON API should be used as basis of decisions where possible.   There's a strong desire to be as compatible as possible with OGC API - Features and OGC API - Records. - Small Reusable Pieces Loosely Coupled - Each specification should be as focused as possible,   defining one core concept and refraining from describing lots of options. Additional options can be made   as separate specifications that build on the core. But the core specs should be small and easily understandable,   with clear defaults for any choice. Handling complex cases should be possible by combining discrete pieces.   Implementors should not be forced to implement lots of options just for basic compliance - they should be   able to pick and choose which pieces are relevant to the problems they are trying to solve. - Focus on the developer. Specifications should aim for implementability - any explanation or design choice   should be considered with a developer audience. And specifications should be accessible to developers who do not   have geospatial background. A developer should not need to understand 'projections' to implement a simple feature   access service. But we should think through the spec extensions they could use in the future when their client asks   for data in a different projection. - Working code required. Proposed changes should be accompanied by working code   (ideally with a link to an online service running the code). A reference implementation should be available   online to power the interactive documentation. Fully accepted specifications should have at least 3 implementations   that cover the entire specification. Extensions have their own Extension Maturity model. - Design for scale. The design should work great with more data than can be imagined right now.   Ideally implementations are built with large test data sets to validate that they will work.   Everything should be compatible with content distribution network (CDN) caching.</p>"},{"location":"principles/#resources","title":"Resources","text":"<ul> <li>Open Source Principles - Producing Open Source Software by Karl Fogel.</li> <li>Best Practices JSON API Design - JSON API best practices for making API's with JSON</li> <li>Pragmatic REST - Web API Design: Crafting interfaces that developers love</li> <li>Open API Initiative - OpenAPIs.org</li> </ul>"},{"location":"catalog-spec/","title":"STAC Catalog Specification","text":"<p>A STAC Catalog is a top-level object that logically groups other Catalog, Collection,  and Item objects.  A Catalog contains an array of Link objects to these other  objects and can include additional metadata to describe the objects contained therein. It is defined in full  in the STAC Catalog Specification.</p> <p>For more information on how the parts of STAC fit together see the overview document.</p> <p>A Catalog is typically the \"entry point\" into a STAC object hierarchy. For example, the root endpoint (\"landing page\") of a STAC API implementation is a Catalog. For many static STAC catalogs (e.g., those defined only by a set of files on disk or in a cloud object store), the root URL points to a Catalog that acts as the starting point to traverse the entire catalog of Catalog, Collection, and Item objects. </p> <p>While STAC Catalogs mostly describe a structure of links and Items, a key related specification is the STAC Collection Specification, which contains fields that further describe the group of Items in a Catalog. </p> <p>A STAC Catalog requires a subset of the fields required by a Collection. These are distinguished from one another by the <code>type</code> field, which will have the value <code>Catalog</code> or <code>Collection</code>. This means that a Collection can be changed to a Catalog simply by changing this <code>type</code> field. The parent-child relationships among Catalogs and Collections are for objects of these types, as there is no subtyping relationship between the Collection and Catalog types, even through they share field names.</p> <p>Catalogs are designed so that a simple file server on the web or object store like Amazon S3 can store JSON that defines a  full Catalog. More dynamic services can also return a Catalog structure, and the STAC API specification contains an OpenAPI definition of the standard way to do this, at the <code>/</code> endpoint. </p>"},{"location":"catalog-spec/#in-this-directory","title":"In this directory","text":"<p>Specification: The main Catalog specification is in catalog-spec.md. It includes in depth explanation of the structures and fields.</p> <p>Schemas: The schemas to validate the core Catalog definition are found in the json-schema/ folder. The primary one is catalog.json.</p>"},{"location":"catalog-spec/#catalog-evolution","title":"Catalog Evolution","text":"<p>The Catalog specification is maturing, but it is still relatively early days. The core of Catalog has been defined very narrowly, to just describe a structure that can be followed by people or machines, so most additional functionality will be defined in additional specifications and extensions. The only anticipated changes to the core of Catalog are to add in additional extension mechanisms for others to use.</p>"},{"location":"catalog-spec/catalog-spec/","title":"STAC Catalog Specification","text":"<ul> <li>Catalog fields</li> <li>stac_version</li> <li>stac_extensions</li> <li>links<ul> <li>Relation types</li> </ul> </li> <li>Media Type for STAC Catalogs</li> <li>Extensions</li> </ul> <p>This document explains the structure and content of a STAC Catalog object. A STAC Catalog object represents a logical group of other Catalog, Collection, and Item objects. These Items can be linked to directly from a Catalog, or the Catalog can link to other Catalogs (often called sub-catalogs) that contain links to Collections and Items. The division of sub-catalogs is up to the implementor, but is generally done to aid the ease of online browsing by people.</p> <p>A Catalog object will typically be the entry point into a STAC catalog. Their purpose is discovery: to be browsed by people or be crawled by clients to build a searchable index.  </p> <p>Any JSON object that contains all the required fields is a valid STAC Catalog object.</p> <ul> <li>Examples</li> <li>See an example catalog.json. The collection.json is also a valid   Catalog file, demonstrating linking to items (it is also a Collection, so has additional fields)</li> <li>JSON Schema</li> </ul> <p>The Catalog section of the Overview document provides background information on the structure of Catalogs as well as links to best practices. This specification lays out the requirements and fields to be compliant.</p> <p>This Catalog specification primarily defines a structure for information to be discoverable. Any use that is publishing a set of related spatiotemporal assets is strongly recommended to also use the STAC Collection specification to provide additional information about the set of Items contained in a Catalog, in order to give contextual information to aid in discovery. STAC Collections all have the same fields as STAC Catalogs, but with different allowed values for <code>type</code> and <code>stac_extensions</code>.</p>"},{"location":"catalog-spec/catalog-spec/#catalog-fields","title":"Catalog fields","text":"Element Type Description type string REQUIRED. Set to <code>Catalog</code> if this Catalog only implements the Catalog spec. stac_version string REQUIRED. The STAC version the Catalog implements. stac_extensions [string] A list of extension identifiers the Catalog implements. id string REQUIRED. Identifier for the Catalog. title string A short descriptive one-line title for the Catalog. description string REQUIRED. Detailed multi-line description to fully explain the Catalog. CommonMark 0.29 syntax MAY be used for rich text representation. links [Link Object] REQUIRED. A list of references to other documents."},{"location":"catalog-spec/catalog-spec/#stac_version","title":"stac_version","text":"<p>In general, STAC versions can be mixed, but please keep the recommended best practices in mind.</p>"},{"location":"catalog-spec/catalog-spec/#stac_extensions","title":"stac_extensions","text":"<p>A list of extensions the Catalog implements. The list consists of URLs to JSON Schema files that can be used for validation. This list must only contain extensions that extend the Catalog specification itself, see the 'Scope' for each of the extensions. This must not declare the extensions that are only implemented in child Collection objects or child Item objects.</p>"},{"location":"catalog-spec/catalog-spec/#links","title":"links","text":"<p>Each link in the <code>links</code> array must be a Link Object.</p>"},{"location":"catalog-spec/catalog-spec/#relation-types","title":"Relation types","text":"<p>All the common relation types can be used in catalog. A <code>self</code> and a <code>root</code> links are STRONGLY RECOMMENDED. Non-root Catalogs SHOULD include a <code>parent</code> link to their parent.</p> <p>[!NOTE] A link to at least one <code>item</code> or <code>child</code> (Catalog or Collection) is RECOMMENDED, but empty catalogs are allowed if there is an intent to populate it or its children were removed.</p>"},{"location":"catalog-spec/catalog-spec/#media-type-for-stac-catalogs","title":"Media Type for STAC Catalogs","text":"<p>A STAC Catalog is a JSON file (RFC 8259), and thus should use the <code>application/json</code> as the Media Type (previously known as the MIME Type).</p>"},{"location":"catalog-spec/catalog-spec/#extensions","title":"Extensions","text":"<p>STAC Catalogs are extensible. Please refer to the extensions overview to find relevant extensions for STAC Catalogs.</p>"},{"location":"collection-spec/","title":"STAC Collection Specification","text":"<p>A STAC Collection object is used to describe a group of related  Items. It builds on fields defined for a Catalog object by further defining and explaining logical groups of Items. A Collection can have parent Catalog and Collection objects, as well as child Item, Catalog,  and Collection objects. These parent-child relationships among objects of these types, as there is no  subtyping relationship between the Collection and Catalog types, even through they share field names.</p> <p>A Collection provides a flexible mechanism to provide additional metadata about a set of Items.  Generally, it is used to describe a set of assets that  are defined with the same properties and share higher-level metadata. There is no  standardized name for this sort of logical grouping, but other places it is called a \" dataset series\" (ESA, ISO 19115), \"collection\" (CNES, NASA), \"dataset\" (JAXA), or \"product\" (JAXA). In GIS terms, the Items are 'features' (that link to assets) and  a Collection is the 'layer'. STAC uses the same terms as the OGC Features API. A STAC Collection is a valid  Feature API Collection,  extending it with additional fields.</p> <p>Thus, the additional fields in a Collection detail the type of information a user would want to  know about the group of Items it contains. Items are required to provide a link back to their  collection definition. But the Collection is independent of STAC Items and STAC Catalogs, and thus  other parties can also use this specification standalone, as a way to describe collections in a  lightweight way. For more details on how the STAC specs fit together see the overview  document. </p>"},{"location":"collection-spec/#in-this-directory","title":"In this directory","text":"<p>Specification: The main STAC Collection specification is in collection-spec.md. It includes an overview and in depth explanation of the  structures and fields.</p> <p>Schemas: The schemas to validate the STAC Collection definition are found in the  json-schema/ folder. The primary one is collection.json.</p>"},{"location":"collection-spec/#collection-flexibility","title":"Collection Flexibility","text":"<p>STAC Collections are defined for flexibility. They only require a handful of fields, and implementors are free to add most any JSON field or object that they want via extensions. This flexibility and extensibility is a design goal, so that it is quite easy to implement a collection and be able to adapt it to most any data model.</p> <p>Implementors are encouraged to do what makes sense for them, and to check out the examples and  other implementations for current best practices.</p> <p>[!NOTE] In cases where a set of Collections is grouped together (e.g. for providing search results), the CollectionCollection object has been defined in the STAC API specification.</p>"},{"location":"collection-spec/collection-spec/","title":"STAC Collection Specification","text":"<ul> <li>Overview</li> <li>Collection fields</li> <li>stac_version</li> <li>stac_extensions</li> <li>id</li> <li>license</li> <li>providers<ul> <li>Provider Object</li> </ul> </li> <li>extents<ul> <li>Extent Object</li> <li>Spatial Extent Object</li> <li>Temporal Extent Object</li> </ul> </li> <li>summaries<ul> <li>Range Object</li> <li>JSON Schema Object</li> </ul> </li> <li>links<ul> <li>Relation types</li> </ul> </li> <li>assets</li> <li>item_assets<ul> <li>Item Asset Definition Object</li> </ul> </li> <li>Media Type for STAC Collections</li> <li>Standalone Collections</li> <li>Extensions</li> </ul>"},{"location":"collection-spec/collection-spec/#overview","title":"Overview","text":"<p>The STAC Collection Specification defines a set of common fields to describe a group of Items that share properties and metadata. The Collection Specification shares all fields with the STAC Catalog Specification (with different allowed values for <code>type</code> and <code>stac_extensions</code>) and adds fields to describe the whole dataset and the included set of Items. Collections can have both parent Catalogs and Collections and child Items, Catalogs and Collections.</p> <p>A STAC Collection is represented in JSON format. Any JSON object that contains all the required fields is a valid STAC Collection and also a valid STAC Catalog.</p> <p>STAC Collections are compatible with the Collection JSON specified in OGC API - Features, but they are extended with additional fields.  </p> <ul> <li>Examples:</li> <li>Sentinel 2: A basic standalone example of a Collection without Items.</li> <li>Simple Example: A Collection that links to 3 example Items.</li> <li>Extension Collection: An additional Collection, which is used to highlight   various extension functionality, but serves as another example.</li> <li>JSON Schema</li> </ul>"},{"location":"collection-spec/collection-spec/#collection-fields","title":"Collection fields","text":"Element Type Description type string REQUIRED. Must be set to <code>Collection</code> to be a valid Collection. stac_version string REQUIRED. The STAC version the Collection implements. stac_extensions [string] A list of extension identifiers the Collection implements. id string REQUIRED. Identifier for the Collection that is unique across all collections in the root catalog. title string A short descriptive one-line title for the Collection. description string REQUIRED. Detailed multi-line description to fully explain the Collection. CommonMark 0.29 syntax MAY be used for rich text representation. keywords [string] List of keywords describing the Collection. license string REQUIRED License(s) of the data collection as SPDX License identifier, SPDX License expression, or <code>other</code> (see below). providers [Provider Object] A list of providers, which may include all organizations capturing or processing the data or the hosting provider. extent Extent Object REQUIRED. Spatial and temporal extents. summaries MapRange Object\\|JSON Schema Object&gt; STRONGLY RECOMMENDED. A map of property summaries, either a set of values, a range of values or a JSON Schema. links [Link Object] REQUIRED. A list of references to other documents. assets MapAsset Object&gt; Dictionary of asset objects that can be downloaded, each with a unique key. item_assets MapItem Asset Definition Object&gt; A dictionary of assets that can be found in member Items."},{"location":"collection-spec/collection-spec/#stac_version","title":"stac_version","text":"<p>In general, STAC versions can be mixed, but please keep the recommended best practices in mind.</p>"},{"location":"collection-spec/collection-spec/#stac_extensions","title":"stac_extensions","text":"<p>A list of extensions the Collection implements. The list consists of URLs to JSON Schema files that can be used for validation. This list must only contain extensions that extend the Collection specification itself, see the 'Scope' for each of the extensions. This must not declare the extensions that are only implemented in child Collection objects or child Item objects.</p>"},{"location":"collection-spec/collection-spec/#id","title":"id","text":"<p>It is important that Collection identifiers are unique across all collections in the corresponding root catalog. Providers should strive as much as possible to make their Collection ids 'globally' unique, prefixing any common information with a unique string. This could be the provider's name if it is a fairly unique name, or their name combined with the domain they operate in.</p>"},{"location":"collection-spec/collection-spec/#license","title":"license","text":"<p>License(s) of the data that the STAC Collection and its children provides. If possible, license information should be defined at the Collection level.</p> <p>The license(s) can be provided as:</p> <ol> <li>SPDX License identifier</li> <li>SPDX License expression</li> <li>String with the value <code>other</code> if the license is not on the SPDX license list.    The strings <code>various</code> and <code>proprietary</code> are deprecated.</li> </ol> <p>If the license is not an SPDX license identifier, links to the license texts SHOULD be added. The links MUST use the <code>license</code> link relation type. If there is no public license URL available, it is RECOMMENDED to supplement the STAC Item with the license text in a separate file and link to this file. If no link to a license is included and the <code>license</code> field is set to <code>other</code> (or one of the deprecated values), the Collection is private, and consumers have not been granted any explicit right to use the data.</p>"},{"location":"collection-spec/collection-spec/#providers","title":"providers","text":"<p>A list of providers, which may include all organizations capturing or processing the data or the hosting provider. Providers should be listed in chronological order with the most recent provider being the last element of the list.</p>"},{"location":"collection-spec/collection-spec/#provider-object","title":"Provider Object","text":"<p>The object provides information about a provider. A provider is any of the organizations that captures or processes the content of the Collection and therefore influences the data offered by this Collection. May also include information about the final storage provider hosting the data.</p> Field Name Type Description name string REQUIRED. The name of the organization or the individual. description string Multi-line description to add further provider information such as processing details for processors and producers, hosting details for hosts or basic contact information. CommonMark 0.29 syntax MAY be used for rich text representation. roles [string] Roles of the provider. Any of <code>licensor</code>, <code>producer</code>, <code>processor</code> or <code>host</code>. url string Homepage on which the provider describes the dataset and publishes contact information. <p>roles: The provider's role(s) can be one or more of the following elements:</p> <ul> <li>licensor: The organization that is licensing the dataset under the license specified in the Collection's <code>license</code> field.</li> <li>producer: The producer of the data is the provider that initially captured and processed the source data, e.g. ESA for Sentinel-2 data.</li> <li>processor: A processor is any provider who processed data to a derived product.</li> <li>host: The host is the actual provider offering the data on their storage.   There should be no more than one host, specified as last element of the list.</li> </ul>"},{"location":"collection-spec/collection-spec/#extents","title":"extents","text":""},{"location":"collection-spec/collection-spec/#extent-object","title":"Extent Object","text":"<p>The object describes the spatio-temporal extents of the Collection. Both spatial and temporal extents are required to be specified.</p> Element Type Description spatial Spatial Extent Object REQUIRED. Potential spatial extents covered by the Collection. temporal Temporal Extent Object REQUIRED. Potential temporal extents covered by the Collection."},{"location":"collection-spec/collection-spec/#spatial-extent-object","title":"Spatial Extent Object","text":"<p>The object describes the spatial extents of the Collection.</p> Element Type Description bbox [[number]] REQUIRED. Potential spatial extents covered by the Collection. <p>bbox: Each outer array element can be a separate spatial extent describing the bounding boxes of the assets represented by this Collection using either 2D or 3D geometries.</p> <p>The first bounding box always describes the overall spatial extent of the data. All subsequent bounding boxes can be used to provide a more precise description of the extent and identify clusters of data. Clients only interested in the overall spatial extent will only need to access the first item in each array. It is recommended to only use multiple bounding boxes if a union of them would then include a large uncovered area (e.g. the union of Germany and Chile). Thus, it doesn't make sense to provide two bounding boxes and the validation will fail in this case.</p> <p>The length of the inner array must be 2*n where n is the number of dimensions. The array contains all axes of the southwesterly most extent followed by all axes of the northeasterly most extent specified in Longitude/Latitude or Longitude/Latitude/Elevation based on WGS 84. When using 3D geometries, the elevation of the southwesterly most extent is the minimum depth/height in meters and the elevation of the northeasterly most extent is the maximum.</p> <p>The coordinate reference system of the values is WGS 84 longitude/latitude. Example that covers the whole Earth: <code>[[-180.0, -90.0, 180.0, 90.0]]</code>. Example that covers the whole earth with a depth of 100 meters to a height of 150 meters: <code>[[-180.0, -90.0, -100.0, 180.0, 90.0, 150.0]]</code>.</p>"},{"location":"collection-spec/collection-spec/#temporal-extent-object","title":"Temporal Extent Object","text":"<p>The object describes the temporal extents of the Collection.</p> Element Type Description interval [[string|null]] REQUIRED. Potential temporal extents covered by the Collection. <p>interval: Each outer array element can be a separate temporal extent. The first time interval always describes the overall temporal extent of the data. All subsequent time intervals can be used to provide a more precise description of the extent and identify clusters of data. Clients only interested in the overall extent will only need to access the first item in each array. It is recommended to only use multiple temporal extents if a union of them would then include a large uncovered time span (e.g. only having data for the years 2000, 2010 and 2020).</p> <p>Each inner array consists of exactly two elements, either a timestamp or <code>null</code>.</p> <p>Timestamps consist of a date and time in UTC and MUST be formatted according to RFC 3339, section 5.6. The temporal reference system is the Gregorian calendar.</p> <p>Open date ranges are supported by setting the start and/or the end time to <code>null</code>. Example for data from the beginning of 2019 until now: <code>[[\"2019-01-01T00:00:00Z\", null]]</code>. It is recommended to provide at least a rough guideline on the temporal extent and thus it's not recommended to set both start and end time to <code>null</code>. Nevertheless, this is possible if there's a strong use case for an open date range to both sides.</p>"},{"location":"collection-spec/collection-spec/#summaries","title":"summaries","text":"<p>Collections are strongly recommended to provide summaries of the values of fields that they can expect from the <code>properties</code> of STAC Items contained in this Collection. This enables users to get a good sense of what the ranges and potential values of different fields in the Collection are, without having to inspect a number of Items (or crawl them exhaustively to get a definitive answer). Summaries are often used to give users a sense of the data in Standalone Collections, describing the potential values even when it can't be accessed as Items. They also give clients enough information to build tailored user interfaces for querying the data, by presenting the potential values that are available.  Fields selected to be included in summaries should capture all the potential values of the  field that appear in every Item underneath the collection, including in any nested sub-Catalogs.</p> <p>A summary for a field can be specified in three ways:</p> <ol> <li>A set of all distinct values in an array: The set of values must contain at least one element and it is strongly recommended to list all values.    If the field summarizes an array (e.g. <code>instruments</code>),    the field's array elements of each Item must be merged to a single array with unique elements.</li> <li>A Range in a Range Object: Statistics by default only specify the range (minimum and maximum values),    but can optionally be accompanied by additional statistical values.    The range specified by the <code>minimum</code> and <code>maximum</code> properties can specify the potential range of values,    but it is recommended to be as precise as possible.</li> <li>Extensible JSON Schema definitions for fine-grained information, see the JSON Schema Object    section for more.</li> </ol> <p>All values must follow the schema of the property field they summarize, unless the field is an array as described in (1) above. So the values in the array or the values given for <code>minimum</code> and <code>maximum</code> must comply to the original data type and any further restrictions that apply for the property they summarize. For example, the <code>minimum</code> for <code>gsd</code> can't be lower than zero and the summaries for <code>platform</code> and <code>instruments</code> must each be an array of strings (or alternatively minimum and maximum values, but that's not very meaningful).</p> <p>It is recommended to list as many properties as reasonable so that consumers get a full overview about the properties included in the Items. Nevertheless, it is not very useful to list all potential <code>title</code> values of the Items. Also, a range for the <code>datetime</code> property may be better suited to be included in the STAC Collection's <code>extent</code> field. In general, properties that are covered by the Collection specification should not be repeated in the summaries.</p> <p>See the examples folder for Collections with summaries to get a sense of how to use them.</p>"},{"location":"collection-spec/collection-spec/#range-object","title":"Range Object","text":"<p>For summaries that would normally consist of a lot of continuous values, statistics can be added instead. By default, only ranges with a minimum and a maximum value can be specified. Ranges can be specified for ordinal values only, which means they need to have a rank order. Therefore, ranges can only be specified for numbers and some special types of strings. Examples: grades (A to F), dates or times. Implementors are free to add other derived statistical values to the object, for example <code>mean</code> or <code>stddev</code>.</p> Field Name Type Description minimum number|string REQUIRED. Minimum value. maximum number|string REQUIRED. Maximum value."},{"location":"collection-spec/collection-spec/#json-schema-object","title":"JSON Schema Object","text":"<p>For a full understanding of the summarized field, a JSON Schema can be added for each summarized field. This allows very fine-grained information for each field and each value as JSON Schema is also extensible. Each schema must be valid against all corresponding values available for the property in the sub-Items. Empty schemas are not allowed.</p> <p>JSON Schema draft-07 is the default JSON Schema version, which aligns with the JSON Schemas provided by STAC. It is allowed to use other versions of JSON Schema if the version is explicitly expressed in the JSON Schema <code>$schema</code> keyword, but tooling may not support JSON Schema versions other than <code>draft-07</code>.</p> <p>For an introduction to JSON Schema, see \"Learn JSON Schema\".</p>"},{"location":"collection-spec/collection-spec/#links","title":"links","text":"<p>This object is described in the Links document.</p>"},{"location":"collection-spec/collection-spec/#relation-types","title":"Relation types","text":"<p>All the common relation types can be used in Collection. A <code>self</code> and a <code>root</code> links are STRONGLY RECOMMENDED. Non-root Collections SHOULD include a <code>parent</code> link to their parent.</p> <p>[!NOTE] The STAC Catalog specification requires a link to at least one <code>item</code> or <code>child</code> Catalog. This is not a requirement for Collections, but recommended. In contrast to Catalogs, it is REQUIRED that Items linked from a Collection MUST refer back to its Collection with a link with the <code>collection</code> relation type.</p>"},{"location":"collection-spec/collection-spec/#assets","title":"assets","text":"<p>Collection Assets provides an optional mechanism to expose assets that don't make sense at the Item level. The property <code>assets</code> is a dictionary of Asset Objects, each with a unique key. Each asset refers to data associated with the Collection that can be downloaded or streamed. This construct is further detailed in the Assets document.</p> <p>There are a few guidelines for using the asset construct at the Collection level:</p> <ul> <li>Collection-level assets SHOULD NOT list any files also available in Items.</li> <li>If possible, item-level assets are always the preferable way to expose assets.</li> </ul> <p>Collection-level assets can be useful in some scenarios, for example:</p> <ol> <li>Exposing additional data that applies Collection-wide and you don't want to expose it in each Item.    This can be Collection-level metadata or a thumbnail for visualization purposes.</li> <li>Individual Items can't properly be distinguished for some data structures,    e.g. Zarr as it's a data structure not contained in single files.</li> <li>Exposing assets for    \"Standalone Collections\".</li> </ol> <p>Often, it is possible to model data and assets with either a Collection or an Item. In those scenarios we recommend to use Items as much as possible, as they are designed for assets. Using Collection-level assets should only be used if there is no other option.</p>"},{"location":"collection-spec/collection-spec/#item_assets","title":"item_assets","text":"<p>This serves two purposes:</p> <ol> <li>Provide a human-readable definition of assets available in any Items    belonging to this Collection so that the user can determine the key(s)    of assets they are interested in.</li> <li>Provide a way to programmatically determine what assets are available    in any member Item. Otherwise a random Item needs to be examined to    determine assets available, but a random Item may not be representative of the set.</li> </ol> <p>An Item Asset Object defined at the Collection level is nearly the same as the Asset Object in Items, except for two differences. The <code>href</code> field is not required, because Item Asset Definitions don't point to any data by themselves, but at least two other fields must be present.</p>"},{"location":"collection-spec/collection-spec/#item-asset-definition-object","title":"Item Asset Definition Object","text":"<p>An item asset is an object that contains details about the datafiles that will be included in member Items. Assets included at the Collection level do not imply that all assets are available from all Items. However, it is recommended that the Asset Definition is a complete set of all assets that may be available from any member Items. So this should be the union of the available assets, not just the intersection of the available assets.</p> Field Name Type Description title string The displayed title for clients and users. description string A description of the Asset providing additional details, such as how it was processed or created. CommonMark 0.29 syntax MAY be used for rich text representation. type string Media type of the asset. roles [string] The semantic roles of the asset, similar to the use of <code>rel</code> in links. <p>Other custom fields, or fields from other extensions may also be included in the Asset object.</p> <p>Any property that exists for a Collection-level asset object must also exist in the corresponding assets object in each Item. If a collection's asset object contains properties that are not explicitly stated in the Item's asset object then that property does not apply to the item's asset. Item asset objects at the Collection-level can describe any of the properties of an asset, but those assets properties and values must also reside in the item's asset object. To consolidate item-level asset object properties in an API setting, consider storing the STAC Item objects without the larger properties internally as 'invalid' STAC items, and merge in the desired properties at serving time from the Collection-level.</p> <p>At least two fields (e.g. <code>title</code> and <code>type</code>) are required to be provided, in order for it to adequately describe Item assets. The two fields must not necessarily be taken from the list above and may include any custom field.</p>"},{"location":"collection-spec/collection-spec/#media-type-for-stac-collections","title":"Media Type for STAC Collections","text":"<p>A STAC Collection is a JSON file (RFC 8259), and thus should use the <code>application/json</code> as the Media Type (previously known as the MIME Type).</p>"},{"location":"collection-spec/collection-spec/#standalone-collections","title":"Standalone Collections","text":"<p>STAC Collections which don't link to any Item are called standalone Collections. To describe them with more fields than the Collection fields has to offer, it is allowed to re-use the metadata fields defined by extensions for Items in the <code>summaries</code> field. This makes much sense for fields such as <code>platform</code> or <code>proj:code</code>, which are often the same for a whole Collection, but doesn't make much sense for <code>eo:cloud_cover</code>, which usually varies heavily across a Collection. The data provider is free to decide, which fields are reasonable to be used.</p>"},{"location":"collection-spec/collection-spec/#extensions","title":"Extensions","text":"<p>STAC Collections are extensible. Please refer to the extensions overview to find relevant extensions for STAC Collections.</p>"},{"location":"commons/assets/","title":"Assets","text":"<ul> <li>Asset Object</li> <li>Media Types</li> <li>Roles</li> <li>Additional Fields</li> </ul> <p>The property <code>assets</code> is a dictionary of Asset Objects, each with a unique key. Each asset refers to data associated with the Item or Collection that can be downloaded or streamed. In general, the keys don't have any meaning and are considered to be non-descriptive unique identifiers. The asset keys used by Items in a Collection should be a static and consistent set across all Items. This allows for effective usage of the STAC Collection <code>item_assets</code> field. Providers may assign any meaning to the keys for their respective use cases, but must not expect that clients understand them. To communicate the purpose of an asset better use the <code>roles</code> field in the Asset Object.</p>"},{"location":"commons/assets/#asset-object","title":"Asset Object","text":"<p>An Asset is an object that contains a URI to data associated with the Item that can be downloaded or streamed. It is allowed to add additional fields.</p> Field Name Type Description href string REQUIRED. URI to the asset object. Relative and absolute URI are both allowed. Trailing slashes are significant. title string The displayed title for clients and users. description string A description of the Asset providing additional details, such as how it was processed or created. CommonMark 0.29 syntax MAY be used for rich text representation. type string Media type of the asset. See the common media types in the best practice doc for commonly used asset types. roles [string] The semantic roles of the asset, similar to the use of <code>rel</code> in links. <p>Additional fields may be added to the assets, though this is recommended only in special cases.</p>"},{"location":"commons/assets/#media-types","title":"Media Types","text":"<p>Any media type can be used in an Item's asset <code>type</code> field, and registered Media Types are preferred. STAC Items that have sidecar metadata files associated with a data asset (e.g, <code>.tfw</code>, Landsat 8 MTL files) should use media types appropriate for the metadata file.  For example, if it is a plain text file, then <code>text/plain</code> would be appropriate; if it is an XML, then <code>text/xml</code> is appropriate. For more information on media types as well as a list of common media types used in STAC see the best practice on working with media types.</p>"},{"location":"commons/assets/#roles","title":"Roles","text":"<p>The <code>roles</code> field is used to describe the purpose of each asset. It is recommended to include one for every asset, to give users a sense of why they might want to make use of the asset. There are some emerging standards that enable clients to take particular action when they encounter particular roles, listed below. But implementors are encouraged to come up with their own terms to describe the role.</p> <p>Like the <code>rel</code> field in Link Objects, the <code>roles</code> field can be given any value. However, there are a few standardized role names that can be found in the best practices. Commonly used are <code>thumbnail</code>, <code>overview</code>, <code>data</code> and <code>metadata</code>.</p> <p>Note that multiple roles per asset are encouraged: pick all the ones that apply. So many should have the <code>data</code> role, and then another role to describe how the data is used. For more information on how to use roles see the Asset Roles section of the Best Practices document.</p>"},{"location":"commons/assets/#additional-fields","title":"Additional Fields","text":"<p>As detailed above, Items contain properties, which are the main source of metadata for searching across Items. Many content extensions can add further property fields as well. Any property that can be specified for an Item can also be specified for a specific asset. This can be used to override a property defined in the Item, or to specify fields for which there is no single value for all assets. If a property is defined in the Item Properties, it is the default value for all assets in the Item. If a property is defined in a Collection on the top-level, it is the default value for all assets in the Collection. Assets may override the properties inherited for specific assets (see example below). Inheritance does not apply across multiple files, i.e. is restricted to a single Item or Collection. Note that in some cases the inheritance may not lead to the expected results if other semantics have been defined for the property. See the example for <code>gsd</code> below. It also applies to some other fields such as <code>created</code> or <code>updated</code>. Inheritance may be undesirable in these cases, e.g. the <code>created</code> attribute of an item would describe when the metadata was generated, whereas on an asset the <code>created</code> attribute would describe when the data file itself was created.</p> <p>It is important to note that the STAC API does not facilitate searching across Asset properties in this way, and this should be used sparingly. It is primarily used to define properties at the Asset level that may be used during use of the data instead of for searching.</p> <p>For example, <code>gsd</code> defined for an Item represents the best Ground Sample Distance (resolution) across all the bands  within the Item. This best spatial resolution (for instance: 10m) is defined in Item properties so it can be  searched on. However any particular band may have a different resolution (for instance: 20m) which is specified on the asset and overrides the Item <code>gsd</code> for this one asset.</p> <p>For examples of fields that this construct is recommended for, see the section of STAC Best Practices that talks about common use cases of additional fields for assets.</p>"},{"location":"commons/common-metadata/","title":"STAC Common Metadata","text":"<p>This document outlines commonly used fields in STAC. They are often used in STAC Item properties, but can also be used in other places, e.g. an Item Asset or Collection Asset.</p> <ul> <li>Basics</li> <li>Date and Time</li> <li>Date and Time Range</li> <li>Licensing</li> <li>License relation</li> <li>Provider</li> <li>Provider Object<ul> <li>roles</li> </ul> </li> <li>Instrument</li> <li>platform</li> <li>instruments</li> <li>constellation</li> <li>mission</li> <li>gsd</li> <li>Bands</li> <li>Band Object</li> <li>Data Values</li> <li>No-data</li> <li>Units</li> <li>Statistics Object</li> <li>Data Types</li> </ul> <p>Various examples are available in the folder <code>examples</code>. JSON Schemas can be found in the folder <code>json-schema</code>.</p> <p>Implementation of any of the fields is not required, unless explicitly required by a specification using the field. For example, <code>datetime</code> is required in STAC Items.</p>"},{"location":"commons/common-metadata/#basics","title":"Basics","text":"<p>Descriptive fields to give a basic overview of a STAC entity (e.g. Catalog, Collection, Item, Asset).</p> <ul> <li>JSON Schema</li> </ul> Field Name Type Description title string A human readable title describing the STAC entity. description string Detailed multi-line description to fully explain the STAC entity. CommonMark 0.29 syntax MAY be used for rich text representation. keywords [string] List of keywords describing the STAC entity. roles [string] The semantic roles of the entity, e.g. for assets, links, providers, bands, etc."},{"location":"commons/common-metadata/#date-and-time","title":"Date and Time","text":"<ul> <li>JSON Schema</li> </ul> <p>Fields to provide additional temporal information such as ranges with a start and an end datetime stamp.</p> Field Name Type Description datetime string|null See the Item Specification Fields for more information. created string Creation date and time of the corresponding STAC entity or Asset (see below), in UTC. updated string Date and time the corresponding STAC entity or Asset (see below) was updated last, in UTC. <p>All timestamps MUST be formatted according to RFC 3339, section 5.6.</p> <p>created and updated have different meaning depending on where they are used. If those fields are available in a Collection, in a Catalog (both top-level), or in a Item (in the <code>properties</code>), the fields refer the metadata (e.g., when the STAC metadata was created). Having those fields in the Assets or Links, they refer to the actual data linked to (e.g., when the asset was created).</p> <p>NOTE: There are more date and time related fields available in the Timestamps extension.</p>"},{"location":"commons/common-metadata/#date-and-time-range","title":"Date and Time Range","text":"<p>While a STAC entity (e.g. an Item) can have a nominal datetime describing the capture, these properties allow a STAC entity to have a range of capture dates and times. An example of this is the MODIS 16 day vegetation index product.</p> <p>Important: Using one of the fields REQUIRES inclusion of the other field as well to enable a user to search STAC records by the provided times. So if you use <code>start_datetime</code> you need to add <code>end_datetime</code> and vice-versa. Both fields are also REQUIRED if the <code>datetime</code> field is set to <code>null</code>. The datetime property in a STAC Item and these fields are not mutually exclusive.</p> Field Name Type Description start_datetime string The first or start date and time for the resource, in UTC. It is formatted as <code>date-time</code> according to RFC 3339, section 5.6. end_datetime string The last or end date and time for the resource, in UTC. It is formatted as <code>date-time</code> according to RFC 3339, section 5.6. <p><code>start_datetime</code> and <code>end_datetime</code> constitute inclusive bounds, meaning that the range covers the entire time interval between the two timestamps and the timestamps itself.</p>"},{"location":"commons/common-metadata/#licensing","title":"Licensing","text":"<p>Information about the license(s) of the data, which is not necessarily the same license that applies to the metadata. Licensing information should be defined at the Collection level if possible.</p> <ul> <li>JSON Schema</li> </ul> Field Name Type Description license string License(s) of the data as SPDX License identifier, SPDX License expression, or <code>other</code> (see below). <p>license: License(s) of the data that the STAC entity provides.</p> <p>The license(s) can be provided as:</p> <ol> <li>SPDX License identifier</li> <li>SPDX License expression</li> <li>String with the value <code>other</code> if the license is not on the SPDX license list.    The strings <code>various</code> and <code>proprietary</code> are deprecated.</li> </ol> <p>If the license is not an SPDX license identifier, links to the license texts SHOULD be added. The links MUST use the <code>license</code> link relation type. If there is no public license URL available, it is RECOMMENDED to supplement the STAC Item with the license text in a separate file and link to this file. If no link to a license is included and the <code>license</code> field is set to <code>other</code> (or one of the deprecated values), the data is private, and consumers have not been granted any explicit right to use it.</p>"},{"location":"commons/common-metadata/#license-relation","title":"License relation","text":"Type Description license The license URL(s) for the resource SHOULD be specified if the <code>license</code> field is not a SPDX license identifier."},{"location":"commons/common-metadata/#provider","title":"Provider","text":"<p>Information about the organizations capturing, producing, processing, hosting or publishing this data. Provider information should be defined at the Collection level if possible.</p> <ul> <li>JSON Schema</li> </ul> Field Name Type Description providers [Provider Object] A list of providers, which may include all organizations capturing or processing the data or the hosting provider. Providers should be listed in chronological order with the most recent provider being the last element of the list."},{"location":"commons/common-metadata/#provider-object","title":"Provider Object","text":"<p>The object provides information about a provider. A provider is any of the organizations that captures or processes the content of the assets and therefore influences the data offered by the STAC implementation. May also include information about the final storage provider hosting the data.</p> Field Name Type Description name string REQUIRED. The name of the organization or the individual. description string Multi-line description to add further provider information such as processing details for processors and producers, hosting details for hosts or basic contact information. CommonMark 0.29 syntax MAY be used for rich text representation. roles [string] Roles of the provider. Any of <code>licensor</code>, <code>producer</code>, <code>processor</code> or <code>host</code>. url string Homepage on which the provider describes the dataset and publishes contact information."},{"location":"commons/common-metadata/#roles","title":"roles","text":"<p>The provider's role(s) can be one or more of the following elements:</p> <ul> <li>licensor: The organization that is licensing the dataset under the license specified in the Collection's <code>license</code> field.</li> <li>producer: The producer of the data is the provider that initially captured and processed the source data, e.g. ESA for Sentinel-2 data.</li> <li>processor: A processor is any provider who processed data to a derived product.</li> <li>host: The host is the actual provider offering the data on their storage.   There should be no more than one host, specified as the last element of the provider list.</li> </ul>"},{"location":"commons/common-metadata/#instrument","title":"Instrument","text":"<p>Adds metadata specifying a platform and instrument used in a data collection mission. These fields will often be combined with domain-specific extensions that describe the actual data, such as the <code>eo</code> or <code>sar</code> extensions.</p> <ul> <li>JSON Schema</li> </ul> Field Name Type Description platform string Unique name of the specific platform to which the instrument is attached. instruments [string] Name of instrument or sensor used (e.g., MODIS, ASTER, OLI, Canon F-1). constellation string Name of the constellation to which the platform belongs. mission string Name of the mission for which data is collected. gsd number Ground Sample Distance at the sensor, in meters (m), must be greater than 0."},{"location":"commons/common-metadata/#platform","title":"platform","text":"<p>The unique name of the specific platform the instrument is attached to. For satellites this would be the name of the satellite, whereas for drones this would be a unique name for the drone. Examples include <code>landsat-8</code> (Landsat-8), <code>sentinel-2a</code> and <code>sentinel-2b</code> (Sentinel-2), <code>terra</code> and <code>aqua</code> (part of NASA EOS, carrying the MODIS instruments), <code>mycorp-uav-034</code> (hypothetical drone name), and <code>worldview02</code> (Maxar/DigitalGlobe WorldView-2).</p>"},{"location":"commons/common-metadata/#instruments","title":"instruments","text":"<p>An array of all the sensors used in the creation of the data. For example, data from the Landsat-8 platform is collected with the OLI sensor as well as the TIRS sensor, but the data is distributed together so would be specified as <code>['oli', 'tirs']</code>. Other instrument examples include <code>msi</code> (Sentinel-2), <code>aster</code> (Terra), and <code>modis</code> (Terra and Aqua), <code>c-sar</code> (Sentinel-1) and <code>asar</code> (Envisat).</p>"},{"location":"commons/common-metadata/#constellation","title":"constellation","text":"<p>The name of a logical collection of one or more platforms that have similar payloads and have their orbits arranged in a way to increase the temporal resolution of acquisitions of data with similar geometric and radiometric characteristics. This field allows users to search for related data sets without the need to specify which specific platform the data came from, for example, from either of the Sentinel-2 satellites. Examples include <code>landsat-8</code> (Landsat-8, a constellation consisting of a single platform), <code>sentinel-2</code> (Sentinel-2), <code>rapideye</code> (operated by Planet Labs), and <code>modis</code> (NASA EOS satellites Aqua and Terra).  In the case of <code>modis</code>, this is technically referring to a pair of sensors on two different satellites, whose data is combined into a series of related products. Additionally, the Aqua satellite is technically part of the A-Train constellation and Terra is not part of a constellation, but these are combined to form the logical collection referred to as MODIS.</p>"},{"location":"commons/common-metadata/#mission","title":"mission","text":"<p>The name of the mission or campaign for collecting data. This could be a discrete set of data collections over a period of time (such as collecting drone imagery), or could be a set of tasks of related tasks from a satellite data collection.</p>"},{"location":"commons/common-metadata/#gsd","title":"gsd","text":"<p>The nominal Ground Sample Distance for the data, as measured in meters on the ground. There are many definitions of GSD. The value of this field should be related to the spatial resolution at the sensor, rather than the pixel size of images after orthorectification, pansharpening, or scaling. The GSD of a sensor can vary depending on geometry (off-nadir / grazing angle) and wavelength, so it is at the discretion of the implementer to decide which value most accurately represents the GSD. For example, Landsat8 optical and short-wave IR bands are all 30 meters, but the panchromatic band is 15 meters. The <code>gsd</code> should be 30 meters in this case because that is the nominal spatial resolution at the sensor. The Planet PlanetScope Ortho Tile Product has an <code>gsd</code> of 3.7 (or 4 if rounding), even though the pixel size of the images is 3.125. For example, one might choose for WorldView-2 the Multispectral 20\u00b0 off-nadir value of 2.07 and for WorldView-3 the Multispectral 20\u00b0 off-nadir value of 1.38.</p>"},{"location":"commons/common-metadata/#bands","title":"Bands","text":"Field Name Type Description bands [Band Object] An array of available bands where each object is a Band Object. <p>The <code>bands</code> array is used to describe the available bands in a STAC entity or Asset. This field describes the general construct of a band or layer, which doesn't necessarily need to be a spectral band. By adding fields from extensions you can indicate that a band, for example, is</p> <ul> <li>a spectral band (EO extension),</li> <li>a band with classification results (classification extension),</li> <li>a band with quality information such as cloud cover probabilities,</li> <li>etc.</li> </ul> <p>Please refer to the Bands best practices for more details.</p> <p>[!NOTE] This property is the successor of the <code>eo:bands</code> and <code>raster:bands</code> fields, which has been present in previous versions of these extensions. The behavior is very similar and they can be migrated easily. Usually, you can simply merge each object on a by-index basis. Nevertheless, you should consider deduplicating properties with the same values across all bands to the asset level (see the best practices). For some fields, you need to add the extension prefix of the <code>eo</code> or <code>raster</code> extension to the property name though. See the Band migration best practice for details.</p>"},{"location":"commons/common-metadata/#band-object","title":"Band Object","text":"<p>Specifically defined for the Band Object is just a single property <code>name</code>, which serves as a unique identifier. You can add additional fields from the common metadata such as a <code>description</code> or the value-related properties.</p> Field Name Type Description name string The name of the band (e.g., \"B01\", \"B8\", \"band2\", \"red\"), which should be unique across all bands defined in the list of bands. This is typically the name the data provider uses for the band. description string Description to fully explain the band. CommonMark 0.29 syntax MAY be used for rich text representation. <p>A Band Object must contain at least one property, which is not necessarily one of the properties defined here and can be a property from an extension or common metadata.</p>"},{"location":"commons/common-metadata/#data-values","title":"Data Values","text":"<p>Adds metadata about the data values or measurement values contained in the entity that is described by the object these fields get added to (e.g., an asset or a band). These fields will often be combined with extensions that group data values into a \"unit\" or \"chunk\", e.g., a band or layer in a file (<code>raster</code> and <code>eo</code> extensions), a column in a table (<code>table</code> extension), or dimensions in a datacube (<code>datacube</code> extension).</p> Field Name Type Description nodata number|string Value used to identify no-data, see below. data_type string The data type of the values, see below. statistics Statistics Object Statistics of all the values. unit string Unit of measurement of the value, see below."},{"location":"commons/common-metadata/#no-data","title":"No-data","text":"<p>The no-data value must be provided either as:</p> <ul> <li>a number</li> <li>a string:</li> <li><code>nan</code> - NaN (not a number) as defined in IEEE-754</li> <li><code>inf</code> - Positive Infinity</li> <li><code>-inf</code> - Negative Infinity</li> </ul>"},{"location":"commons/common-metadata/#units","title":"Units","text":"<p>It is STRONGLY RECOMMENDED to provide units in one of the following two formats:</p> <ul> <li>UCUM: The unit code that is compliant to the UCUM specification.</li> <li>UDUNITS-2: The unit symbol if available, otherwise the singular unit name.</li> </ul>"},{"location":"commons/common-metadata/#statistics-object","title":"Statistics Object","text":"<p>Statistics usually specify the range of values by providing the <code>minimum</code> and <code>maximum</code> values, but can optionally be accompanied by additional statistical values. Some additional statistical sizes are listed below, but the object can also be extended with other statistical sizes that are not listed below. For example, it could list additional coverages such as vegetation cover, land cover, etc. If statistics are provided in the Item Properties (example), it is recommended to list the statistical sizes with a JSON Schema in the Collection Summaries to better describe the sizes (example). Please note that some statistical sizes such as cloud cover have explicit fields in other extensions such as the EO extension. It is recommended to use the fields standardized in extensions in favor of providing them in the Statistics Object.</p> Field Name Type Description minimum number minimum value of the values in the band. If not present, the minimum value of the given data type or negative infinity can be assumed. maximum number maximum value of the values in the band. If not present, the maximum value of the given data type or positive infinity can be assumed. mean number mean value of all the values in the band stddev number standard deviation value of the values in the band count integer Total number of all data values (&gt;= 0) valid_percent number Percentage of valid (not <code>nodata</code>) values (0-100)"},{"location":"commons/common-metadata/#data-types","title":"Data Types","text":"<p>The data type gives information about the values. This can be used to indicate the (maximum) range of numerical values expected. For example <code>uint8</code> indicates that the numbers are in a range between 0 and 255, they can never be smaller or larger. This can help to pick the optimal numerical data type when reading the files to keep memory consumption low. Nevertheless, it doesn't necessarily mean that the expected values fill the whole range. For example, there can be use cases for <code>uint8</code> that just use the numbers 0 to 10 for example. Through the Statistics Object it is possible to specify an exact value range so that visualizations can be optimized. The allowed values for <code>data_type</code> are:</p> <ul> <li><code>int8</code>: 8-bit integer</li> <li><code>int16</code>: 16-bit integer</li> <li><code>int32</code>: 32-bit integer</li> <li><code>int64</code>: 64-bit integer</li> <li><code>uint8</code>: unsigned 8-bit integer (common for 8-bit RGB PNG's)</li> <li><code>uint16</code>: unsigned 16-bit integer</li> <li><code>uint32</code>: unsigned 32-bit integer</li> <li><code>uint64</code>: unsigned 64-bit integer</li> <li><code>float16</code>: 16-bit float</li> <li><code>float32</code>: 32-bit float</li> <li><code>float64</code>: 64-big float</li> <li><code>cint16</code>: 16-bit complex integer</li> <li><code>cint32</code>: 32-bit complex integer</li> <li><code>cfloat32</code>: 32-bit complex float</li> <li><code>cfloat64</code>: 64-bit complex float</li> <li><code>other</code>: Other data type than the ones listed above (e.g. boolean, string, higher precision numbers)</li> </ul>"},{"location":"commons/links/","title":"Links","text":"<ul> <li>Link Object</li> <li>HTTP headers</li> <li>Media Types</li> <li>STAC Media Types</li> <li>Relation Types</li> <li>Hierarchical relations<ul> <li><code>self</code> relation</li> <li><code>root</code> and <code>parent</code> relation</li> <li><code>child</code> relation</li> <li><code>collection</code> and <code>item</code> relation</li> </ul> </li> </ul>"},{"location":"commons/links/#link-object","title":"Link Object","text":"<p>This object describes a relationship with another entity. Data providers are advised to be liberal with the links section, to describe things like the Catalog an Item is in, related Items, parent or child Items (modeled in different ways, like an 'acquisition' or derived data).</p> Field Name Type Description href string REQUIRED. The actual link in the format of an URL. Relative and absolute links are both allowed. Trailing slashes are significant. rel string REQUIRED. Relationship between the current document and the linked document. See chapter \"Relation types\" for more information. type string Media type of the referenced entity. title string A human readable title to be used in rendered displays of the link. method string The HTTP method that shall be used for the request to the target resource, in uppercase. <code>GET</code> by default headers Map The HTTP headers to be sent for the request to the target resource. body any The HTTP body to be sent to the target resource. <p>For a full discussion of the situations where relative and absolute links are recommended see the 'Use of links' section of the STAC best practices.</p>"},{"location":"commons/links/#http-headers","title":"HTTP headers","text":"<p>The field <code>headers</code> allows to describe a dictionary of HTTP headers that are required to be sent by the client. The keys of the dictionary are the header names, and the values are either a single string or an array of strings. In case of an array, the header is expected to be sent multiple times with the different values.</p>"},{"location":"commons/links/#media-types","title":"Media Types","text":"<p>One of the best ways to help inform web clients about the content in a link is to use a common Media Type in the <code>type</code> field. In STAC the <code>type</code> field is used in both the Link Object and in the Asset Object. It is quite useful for STAC browsers to better determine what to render and display to users searching and browsing the Catalog. Media types are sometimes referred to by the now deprecated term \"MIME types\".</p>"},{"location":"commons/links/#stac-media-types","title":"STAC Media Types","text":"<p>The following table lists the Media Types to use for STAC entities.</p> Media Type Description <code>application/geo+json</code> A STAC Item <code>application/json</code> A STAC Catalog <code>application/json</code> A STAC Collection"},{"location":"commons/links/#relation-types","title":"Relation Types","text":"<p>STAC Entities use a variety of <code>rel</code> types in the Link Object, to describe the exact nature of the link between the STAC object and the entity it is linking to. It is recommended to use the official IANA Link Relation Types where possible.</p>"},{"location":"commons/links/#hierarchical-relations","title":"Hierarchical relations","text":"<p>The following table lists the STAC-specific <code>rel</code> types that are used in the <code>links</code> object of a STAC entity to link with other STAC entities in the same catalog.</p> Type Description Media Type self Absolute URL to the location that the STAC file can be found online, if available. application/json root URL to the root STAC entity (Catalog or Collection). application/json parent URL to the parent STAC entity (Catalog or Collection). application/json child URL to a child STAC entity (Catalog or Collection). application/json collection URL to the parent Collection. Absolute URLs should be used whenever possible. application/json item URL to a STAC Item. application/geo+json (preferred) or application/json"},{"location":"commons/links/#self-relation","title":"<code>self</code> relation","text":"<p>The <code>self</code> relation is used to link to the STAC entity itself. This is particularly useful when in a download package that includes metadata, so that the downstream user can know where the data has come from.</p>"},{"location":"commons/links/#root-and-parent-relation","title":"<code>root</code> and <code>parent</code> relation","text":"<p>The <code>root</code> and <code>parent</code> relations are used to link to the root and parent STAC entity, which is either a Catalog or a Collection. Conceptually, STAC entities SHALL have no more than one parent entity. As such, STAC entities also can have no more than one root entity. Therefore, there's usually just one link with <code>root</code> or <code>parent</code> relationship unless different variations of the same conceptual entity exist (identified by the ID). Different variations could be:</p> <ul> <li>a different encoding (see the <code>type</code> property), e.g. a HTML version in addition to JSON</li> <li>a different language (see the <code>hreflang</code> property). e.g. a German version in addition to English</li> </ul>"},{"location":"commons/links/#child-relation","title":"<code>child</code> relation","text":"<p>The <code>child</code> relation is ONLY used to link a catalog or collection to a child catalog or collection.</p>"},{"location":"commons/links/#collection-and-item-relation","title":"<code>collection</code> and <code>item</code> relation","text":"<p>The <code>collection</code> and <code>item</code> relations are used to link to the parent collection and a child Item, respectively. It is RECOMMENDED to link an <code>item</code> from a collection and not directly from a catalog. All Items linked from a Collection MUST refer back to its Collection with the <code>collection</code> relation type The referenced Collection is STRONGLY RECOMMENDED to implement the same STAC version as the Collection.</p>"},{"location":"examples/","title":"STAC Examples","text":"<p>This directory contains various examples for all parts of the STAC specification. It is structured to be two valid STACs, meaning both catalog.json and collection.json should successfully load in various tools. They do not follow all the best practices for STAC, mostly due to the fact that they contrive examples to show the spec and we are hosting in GitHub. But we note below where they differ from an ideal catalog.</p> <p>The various fields are mostly fictional, to be able to demonstrate the various aspects of the spec as tersely as possible. To get a sense of real world STAC implementations we recommend exploring the various catalogs listed on STAC Index, to see full catalogs in production.</p>"},{"location":"examples/#organization","title":"Organization","text":"<p>This directory contains two STAC implementations, both valid, but simplified a bit to be illustrative of the key concepts, so  they do not quite follow all the best practices. </p>"},{"location":"examples/#simple-collection","title":"Simple Collection","text":"<p>This STAC implementation consists of three files, all contained at the root of the examples directory</p> <p>collection.json is a minimal 'simple collection', that links to three items. </p> <p>simple-item.json is the most minimal possible compliant Item record. Most all data will include additional fields, as STAC is designed to be a minimal common subset. But it is useful for showing exactly what is required.</p> <p>core-item.json is a more realistic example, for a hypothetical analytic image  acquisition from a satellite company called 'Remote Data'. It includes additional fields covering the common  metadata. It also links to a variety of assets that is typical for satellite imagery, as most providers include a number of complementary files.</p> <p>extended-item.json is arguably an even more realistic example, as it includes a number of the extensions that are commonly used, to demonstrate how implementations tend to start with the core, and add in a number of the core extensions. </p> <p>collectionless-item.json demonstrates the common metadata that is only used when an Item does not have  a collection. It is recommended to organize items in collections, but we wanted to show how this works. This is not technically in the 'simple collection' of this section, but it follows the same pattern, so is included here.</p>"},{"location":"examples/#nested-catalog","title":"Nested Catalog","text":"<p>This STAC implementation shows a common pattern, starting with a catalog that links to a number of distinct collections, which may link down to a number of items.</p> <p>catalog.json is a minimal catalog implementation, linking to two other collections.</p> <p>collection-only/collection.json is a collection that does not link to any items. This demonstrates how is is possible to make use of STAC Collections without needing items, to serve as nice summarizing metadata for  tools that work with full layers / collections. This example collection is based on real Sentinel-2 values, so is not quite fictional, but should be taken as just an example.</p> <p>extensions-collection/collection.json contains a small number of items, that demonstrate more functionality available in STAC extensions. These are linked to directly from the individual extensions. These items follow the recommendations for Catalog Layout Best Practices.</p>"},{"location":"examples/#in-depth","title":"In Depth","text":"<p>As mentioned above, the files in this examples directory form valid STAC implementations. They are all based on a  fictional remote sensing company called 'Remote Data', with a URL at remotedata.io. This domain has not been set up, so those links will not work, but any valid data provider should provide valid links to their homepage. </p> <p>The examples use the <code>rd:</code> prefix to show how providers can use custom fields when there are not set fields. In the examples these do not link to a schema which is completely valid, but it is recommended that providers do write a JSON schema that can validate  their custom fields (we will work to add an example schema for the <code>rd:</code> fields in the future). </p>"},{"location":"examples/#catalog-type","title":"Catalog Type","text":"<p>One of the most important STAC Best Practices is to use links consistently, following one of the described 'catalog types'. The catalogs described here are Relative Published Catalogs, that use absolute URL's to refer to their assets (so would be an example of a Self-contained Metadata  Only catalog that is published).</p>"},{"location":"examples/#differences-with-stac-best-practices","title":"Differences with STAC Best Practices","text":"<p>One of the most important documents in this repository is the one about best practices. It describes a number of practical recommendations gained by people actually implementing STAC. The core spec is designed to be as flexible as possible, so that it is not too rigid and unable to handle unanticipated needs. But we recommend following as many of the best practices as is  feasible, as it will help ensure various STAC tools work much better. The examples in this folder don't align with all the best practices, mostly because they are meant to demonstrate things as tersely as possible, and also because they live directly inside a github repository. As many people will look at these examples and take them as 'how things should be' we felt its important to highlight where things here differ from the actual best practices.</p>"},{"location":"examples/#catalog-layout","title":"Catalog Layout","text":"<p>Another important recommendations concerns the layout of STAC catalogs. This is important for tools to be able to expect a certain layout, and most tools will follow the described layout. The simple collection that consists of the collection.json and its 3 linked items violates this. This is done to be able to show item examples directly in the root of the 'examples' folder, so people don't have to dig deep into folders to get a quick example. But a proper catalog layout would put the items in sub-directories, along with their assets.</p>"},{"location":"extensions/","title":"Extensions","text":"<ul> <li>Extensions</li> <li>Overview</li> <li>Using Extensions<ul> <li>Extension identifiers in <code>stac_extensions</code></li> </ul> </li> <li>Community Extensions<ul> <li>Proposed extensions</li> </ul> </li> <li>Extension Maturity</li> <li>Extending STAC<ul> <li>General Conventions</li> <li>Proposing new extensions</li> <li>Prefixes</li> <li>Use of arrays and objects</li> </ul> </li> </ul>"},{"location":"extensions/#overview","title":"Overview","text":"<p>One of the most important aspects of the SpatioTemporal Asset Catalog specification is its extensibility. The core STAC specification defines only a minimal core, but is designed for extension. It is expected that most real-world implementations will use several 'extensions' to fully describe their data. This document describes how extensions work.</p> <p>For a list of most available extensions see the STAC extensions overview page. Please note the extension maturity for each extension.</p> <p>Extensions to the core STAC specification provide additional fields that can be used to better describe the data. Most tend to be about describing a particular domain or type of data, but some imply functionality.</p> <p>Extensions include a JSON Schema precisely describing the structure, a natural language description of the fields, and thorough examples.</p> <p>Anybody can create an extension for their data, and data providers often work together to share fields between them to create a shared community extension. See the section below on 'Extending STAC') for information on how to get started. Everyone is encouraged to add their extensions to the  STAC extensions overview page, so others can be aware of it.</p> <p>Each extension should have at least one owner. You can find extension owners in each extension's README.</p>"},{"location":"extensions/#using-extensions","title":"Using Extensions","text":"<p>When deciding how to model data in STAC it is highly recommended to first look at the list of extensions and re-use fields there instead of creating your own version. This increases interoperability, as users know that the meaning of your fields is the same as in other STAC  implementations. Many clients will also understand more mature extensions for better display and querying. </p> <p>To incorporate an extension in STAC the 'Identifier' of the extension must be added to the <code>stac_extensions</code> array of the STAC Catalog,  Collection or Item object. This identifier is a URL to the JSON Schema that allows to validate the fields in the extension. These JSON Schema URLs also include the version number of the extension. The 'Identifier' can usually be found in the first lines of the README of any extension made with the extension template.</p>"},{"location":"extensions/#extension-identifiers-in-stac_extensions","title":"Extension identifiers in <code>stac_extensions</code>","text":"<p>Generally, if an extension is implemented in a STAC file in a place where the extension scope applies to,  the extension identifier should be added to the <code>stac_extension</code> array. The scope of an extension is usually explained in the README of an extension. Implementing an extension by following the specified requirements usually means including  fields, but occasionally also means implementing alternate behaviors.</p> <p>There is no direct inheritance between children and parents though, so if for example an Item implements an extension, but the Collection doesn't reflect the usage of the extension, the extension identifier must only be added to the <code>stac_extension</code> array in the Item, but not to the Collection. If the Collection itself implements the extension though or 'summarizies' a field in Collection Summaries or Item Asset Definitions, the extension identifier should be added to the Collection.</p> <p>Examples</p> <ul> <li>If the Catalog, Collection or Item object directly implements the extension,   the <code>stac_extensions</code> of that object should contain the extension Identifier.</li> <li>If an Asset object implements an extension, the <code>stac_extensions</code> of the Item or Collection which holds that   Asset should contain the extension identifier.</li> <li>If a Collection summary contains Item fields that implement an extension, then   the <code>stac_extensions</code> array of that Collection should list the extension identifier. For example, if a Collection <code>summaries</code> field   contains a summary of <code>eo:cloud_cover</code>, then that Collection should have the EO extension JSON Schema URL in the <code>stac_extensions</code> array.</li> <li>If an object implements an extension that results in fields from a separate extension to be referenced, then the latter extension   identifier should be included in the <code>stac_extensions</code> array for that object. For example, if a Collection implements the   item_assets extension, and in the <code>item_assets</code> field there is an Asset Definition   which includes <code>proj:wkt2</code>, then the Projection extension identifier should be listed in that Collection's <code>stac_extensions</code>.</li> </ul>"},{"location":"extensions/#community-extensions","title":"Community Extensions","text":"<p>Everyone is welcome to contribute extensions to the STAC ecosystem. The center of activity for these is the stac-extensions GitHub organization, which has a number of extension repositories. Some of these, especially the stable extensions, are observed by the STAC PSC. The community can also host STAC extensions in other places, but we encourage the community to at least list them in the STAC extensions overview page so that everyone can be aware of all extensions at any time and a high level of interoperability is possible.</p>"},{"location":"extensions/#proposed-extensions","title":"Proposed extensions","text":"<p>Beyond the community extensions there have been a number of extensions that people have proposed to the STAC community. These can be found in the STAC Issue Tracker under the  new extension label. These are ideas that others would likely use and potentially collaborate on. Anyone is free to add new ideas there, and see the section below on proposing new extensions for the workflow to advance ideas into full-fledged community extensions.</p>"},{"location":"extensions/#extension-maturity","title":"Extension Maturity","text":"<p>There are many extensions being built with STAC, but they have varying degrees of maturity. All community extensions listed here included must include a maturity classification, so that STAC spec users can easily get a sense of how much they can count on the extension.</p> Maturity Classification Min Impl # Description Stability Proposal 0 An idea put forward by a community member to gather feedback Not stable - breaking changes almost guaranteed as implementers try out the idea. Pilot 1 Idea is fleshed out, with examples and a JSON schema, and implemented in one or more catalogs. Additional implementations encouraged to help give feedback Approaching stability - breaking changes are not anticipated but can easily come from additional feedback. Candidate 3 A number of implementers are using it and are standing behind it as a solid extension. User can generally count on an extension at this maturity level. Mostly stable, breaking changes require a new version and minor changes are unlikely. The extension has a code owner, designated in its README. Stable 6 Highest current level of maturity. The community of extension maintainers commits to a STAC review process for any changes, which are not made lightly. Completely stable, all changes require a new version number and review process. Deprecated N/A A previous extension that has likely been superseded by a newer one or did not work out for some reason. DO NOT USE, is not supported <p>Maturity mostly comes through diverse implementations, so the minimum number of implementations column is the main gating function for an extension to mature. But extension authors can also choose to hold back the maturity advancement if they don't feel they are yet ready to commit to the less breaking changes of the next level.</p>"},{"location":"extensions/#extending-stac","title":"Extending STAC","text":"<p>Anyone is welcome to extend STAC and evolve the additions into a full STAC extension with a README, JSON Schema and examples. There are several types of extensions, some just add additional fields, some change the behavior of STAC and some introduce completely new functionality. New extensions should try to align with existing extensions as well as possible and may even re-use fields and their definitions until they may get split into a new extension that combines commonly used fields across multiple extensions.</p>"},{"location":"extensions/#general-conventions","title":"General Conventions","text":"<p>Creating a new extension usually involves defining a set of logically grouped fields, and specifying what the allowed values for those fields are. This should be done in the extension text (README) and in JSON Schema, to provide validation. While one  can theoretically add fields anywhere in JSON there are some conventions as to where to add them in STAC objects.</p> <ol> <li>Additional attributes relating to an Item should be added into the Item Properties object,    rather than directly in the Item object.</li> <li>In general, additional attributes that apply to an Item Asset should also be allowed in Item Properties and vice-versa.    For example, the <code>gsd</code> attribute may be used in Item Properties to describe the best GSD available in    the Item Asset objects contained in the Item, but may also be used in an individual Item Asset to describe only the specific GSD of that asset.</li> <li>Additional attributes relating to a Catalog or    Collection should be added to the top-level of the object.</li> <li>All other objects can generally also be extended, e.g. Link Objects, Provider Objects, Band Objects, etc.</li> <li>Extensions may also extend other extensions, declaring that dependency in the text and JSON Schema.</li> </ol>"},{"location":"extensions/#proposing-new-extensions","title":"Proposing new extensions","text":"<p>Extensions can be hosted anywhere, but should use the extension template  as a starting point. If you'd like to add a repository to the stac-extensions  GitHub organization, just ask on Gitter! This is fine for  work-in-progress extensions. You can also host the extension repository in your own GitHub account, and optionally  transfer it to the stac-extensions organization later.</p> <p>For new extensions that require community discussion, we recommend the following workflow:</p> <ul> <li>Use the stac-extensions template to sketch out your proposed extension</li> <li>Open an issue on this repository with the prefix \"New Extension: \" and describe the extension. Include a link to the extension repository.   Also post it in the Gitter chat for broader recognition.</li> <li>Discussion should take place as issues/pull requests on the extension repository directly, but can als occur on the issue created before.</li> <li>Once the extension has an initial release, the issue on stac-spec will be closed.</li> </ul>"},{"location":"extensions/#prefixes","title":"Prefixes","text":"<p>A STAC Item can combine schema information from several different sources - the core STAC Item information, an earth observation community extension, and a vendor specific provider. It can be difficult to distinguish exactly where each definition came from, and to pull out the most relevant information, especially when vendors often will dump in all the metadata they have in to the STAC definition.</p> <p>So one idea is to have prefixes to differentiate specific vendors (like <code>dg:</code> for DigitalGlobe), and for communities of practice (like <code>eo:</code> for Electro-Optical). These wouldn't be full namespacing, though an extension for like JSON-LD could potentially evolve to make fully resolved namespacing an option.</p> <p>An example of this can be seen in a Landsat example:</p> <pre><code>  \"properties\": {\n    \"datetime\":\"2018-01-01T13:21:30Z\",\n\n    \"start_datetime\":\"2018-01-01T13:21:30Z\",\n    \"end_datetime\":\"2018-01-01T13:31:30Z\",\n\n    \"view:off_nadir\": -0.001,\n    \"eo:cloud_cover\": 10.31,\n    \"view:sun_azimuth\": 149.01607154,\n    \"view:sun_elevation\": 59.21424700,\n    \"gsd\": 30,\n\n    \"l8:data_type\": \"L1T\",\n    \"l8:wrs_path\": 153,\n    \"l8:wrs_row\": 25,\n    \"l8:earth_sun_distance\": 1.0141560,\n    \"l8:ground_control_points_verify\": 114,\n    \"l8:geometric_rmse_model\": 7.562,\n    \"l8:image_quality_tirs\": 9,\n    \"l8:ground_control_points_model\": 313,\n    \"l8:geometric_rmse_model_x\": 5.96,\n    \"l8:geometric_rmse_model_y\": 4.654,\n    \"l8:geometric_rmse_verify\": 5.364,\n    \"l8:image_quality_oli\": 9\n  }\n</code></pre>"},{"location":"extensions/#use-of-arrays-and-objects","title":"Use of arrays and objects","text":"<p>For extensions, it is recommended to</p> <ol> <li>Use arrays only as enumerations/lists (possibly sorted), without implying additional meaning (such as order)</li> <li>To avoid using nested objects, in favor of multiple attributes with a similar naming scheme.</li> </ol> <p>For example, if one would like to define an extension to contain a start and a end date, there are multiple options (tl;dr: option 3 is recommended):</p> <ol> <li>Define an object, for example: <code>\"date_range\": {\"start\": \"2018-01-01\", \"end\": \"2018-01-31\"}</code>.    This is discouraged as it is more complex to search in objects.</li> <li>Define an two-element array where the first element is the start date and the second element is the end date,    for example <code>\"date_range\": [\"2018-01-01\", \"2018-01-31\"]</code>.    This is discouraged as it would conflict with Collection <code>summaries</code>,    which always considers arrays as true (potentially sorted) enumeration without any additional meaning.</li> <li>Define two separate fields, e.g. <code>\"date_range_start\": \"2018-01-01\", \"date_range_end\": \"2018-01-31\"</code>.    This is recommended as it avoids the conflicts above and is usually better displayed in software that only understands GeoJSON    but has no clue about STAC.    This is due to the fact that most legacy software can not display arrays or objects GeoJSON <code>properties</code> properly.</li> </ol> <p>This rules only applies to the fields defined directly for the Item's <code>properties</code>. For fields and structures defined on other levels (e.g. in the root of an Item or in an array), extension authors can freely define the structure. So an array of objects such as the <code>bands</code> are fine to use, but keep in mind that the drawbacks mentioned above usually still apply.</p>"},{"location":"item-spec/","title":"STAC Item Specification","text":"<p>The STAC Item object is the most important object in a STAC system. An Item is the entity that contains metadata for a scene and links to the assets. </p> <p>Item objects are the leaf nodes for a graph of Catalog  and Collection objects. See the  overview document for more information about how these objects relate  to each other.</p>"},{"location":"item-spec/#in-this-directory","title":"In this directory","text":"<p>Specification: The STAC Item specification is in  item-spec.md. It includes an overview and an in-depth explanation of the fields.</p> <p>Schemas: The JSON Sschema in item.json  defines an Item object. The basics,  datetime, instrument,  licensing, and provider schemas validate additional fields defined in Common Metadata.</p> <p>Common Metadata: A set of commonly-used fields for STAC Items is listed in  common-metadata.md.</p> <p>[!NOTE] In cases where a set of Items is grouped together (e.g. for providing search results), the ItemCollection object has been defined in the STAC API specification.</p> <p>Similarly to the relationship between a GeoJSON Feature and a STAC Item, a STAC ItemCollection should be a valid GeoJSON FeatureCollection to allow interoperability with existing tools that support GeoJSON.</p>"},{"location":"item-spec/common-metadata/","title":"STAC Common Metadata","text":"<p>The document has moved to the <code>commons</code> folder: STAC Common Metadata</p>"},{"location":"item-spec/item-spec/","title":"STAC Item Specification","text":"<ul> <li>Overview</li> <li>Item fields</li> <li>stac_version</li> <li>stac_extensions</li> <li>id</li> <li>geometry</li> <li>bbox</li> <li>collection</li> <li>properties<ul> <li>Properties Object</li> <li>datetime</li> <li>Additional Fields</li> </ul> </li> <li>Links<ul> <li>Relation types</li> <li>Collections</li> </ul> </li> <li>Assets</li> <li>Media Type for STAC Item</li> <li>Extensions</li> </ul>"},{"location":"item-spec/item-spec/#overview","title":"Overview","text":"<p>This document explains the structure and content of a SpatioTemporal Asset Catalog (STAC) Item. An Item is a GeoJSON Feature augmented with foreign members relevant to a STAC object. These include fields that identify the time range and assets of the Item. An Item is the core object in a STAC Catalog, containing the core metadata that enables any client to search or crawl online catalogs of spatial 'assets' (e.g., satellite imagery, derived data, DEMs).</p> <p>The same Item definition is used in both STAC Catalogs and the Item-related API endpoints. Catalogs are simply sets of Items that are linked online, generally served by simple web servers and used for crawling data. The search endpoint enables dynamic queries, for example selecting all Items in Hawaii on June 3, 2015, but the results they return are FeatureCollections of Items.</p> <p>Items are represented in JSON format and are very flexible. Any JSON object that contains all the required fields is a valid STAC Item.</p> <ul> <li>Examples:</li> <li>See the minimal example,     as well as a more fleshed example that contains a number of current best practices.</li> <li>Real world implementations are also available.</li> <li>JSON Schema</li> </ul>"},{"location":"item-spec/item-spec/#item-fields","title":"Item fields","text":"<p>This object describes a STAC Item. The fields <code>id</code>, <code>type</code>, <code>bbox</code>, <code>geometry</code> and <code>properties</code> are inherited from GeoJSON.</p> Field Name Type Description type string REQUIRED. Type of the GeoJSON Object. MUST be set to <code>Feature</code>. stac_version string REQUIRED. The STAC version the Item implements. stac_extensions [string] A list of extensions the Item implements. id string REQUIRED. Provider identifier. The ID should be unique within the Collection that contains the Item. geometry GeoJSON Geometry Object | null REQUIRED. Defines the full footprint of the asset represented by this item, formatted according to RFC 7946, section 3.1 if a geometry is provided or section 3.2 if no geometry is provided. bbox [number] REQUIRED if <code>geometry</code> is not <code>null</code>, prohibited if <code>geometry</code> is <code>null</code>. Bounding Box of the asset represented by this Item, formatted according to RFC 7946, section 5. properties Properties Object REQUIRED. A dictionary of additional metadata for the Item. links [Link Object] REQUIRED. List of link objects to resources and related URLs. See the best practices for details on when the use <code>self</code> links is strongly recommended. assets MapAsset Object&gt; REQUIRED. Dictionary of asset objects that can be downloaded, each with a unique key. collection string The <code>id</code> of the STAC Collection this Item references to. This field is required if a link with a <code>collection</code> relation type is present and is not allowed otherwise."},{"location":"item-spec/item-spec/#stac_version","title":"stac_version","text":"<p>In general, STAC versions can be mixed, but please keep the recommended best practices in mind.</p>"},{"location":"item-spec/item-spec/#stac_extensions","title":"stac_extensions","text":"<p>A list of extensions the Item implements. The list consists of URLs to JSON Schema files that can be used for validation. This list must only contain extensions that extend the Item specification itself, see the 'Scope' for each of the extensions.</p>"},{"location":"item-spec/item-spec/#id","title":"id","text":"<p>It is important that an Item identifier is unique within a Collection, and that the Collection identifier in turn is unique globally. Then the two can be combined to give a globally unique identifier. Items are strongly recommended to have Collections, and not having one makes it more difficult to be used in the wider STAC ecosystem. If an Item does not have a Collection, then the Item identifier should be unique within its root Catalog or root Collection.</p> <p>As most geospatial assets are already uniquely defined by some  identification scheme from the data provider it is recommended to simply use that ID. Data providers are advised to include sufficient information to make their IDs globally unique, including things like unique satellite IDs. See the id section of best practices for additional recommendations.</p>"},{"location":"item-spec/item-spec/#geometry","title":"geometry","text":"<p>Defines the full footprint of the asset represented by this item, formatted according to RFC 7946.</p> <p>If a geometry is provided, the value must be a Geometry Object according to RFC 7946, section 3.1 with the exception that the type <code>GeometryCollection</code> is not allowed in STAC. If no geometry is provided, the value must be <code>null</code> according to RFC 7946, section 3.2.</p> <p>Coordinates are specified in Longitude/Latitude or Longitude/Latitude/Elevation based on WGS 84.</p>"},{"location":"item-spec/item-spec/#bbox","title":"bbox","text":"<p>Bounding Box of the asset represented by this Item using either 2D or 3D geometries, formatted according to RFC 7946, section 5. The length of the array must be 2*n where n is the number of dimensions. The array contains all axes of the southwesterly most extent followed by all axes of the northeasterly most extent specified in Longitude/Latitude or Longitude/Latitude/Elevation based on WGS 84. When using 3D geometries, the elevation of the southwesterly most extent is the minimum depth/height in meters and the elevation of the northeasterly most extent is the maximum. This field enables more naive clients to easily index and search geospatially. STAC compliant APIs are required to compute intersection operations with the Item's geometry field, not its bbox.</p>"},{"location":"item-spec/item-spec/#collection","title":"collection","text":"<p>The <code>id</code> of the STAC Collection this Item references to with the <code>collection</code> relation type in the <code>links</code>  array.</p> <p>This field provides an easy way for a user to search for any Items that belong in a specified Collection. If present, must be a non-empty string.</p>"},{"location":"item-spec/item-spec/#properties","title":"properties","text":""},{"location":"item-spec/item-spec/#properties-object","title":"Properties Object","text":"<p>Additional metadata fields can be added to the GeoJSON Object Properties. The only required field is <code>datetime</code> but it is recommended to add more fields, see Additional Fields resources below.</p> Field Name Type Description datetime string|null REQUIRED. The searchable date and time of the assets, which must be in UTC. It is formatted according to RFC 3339, section 5.6. <code>null</code> is allowed, but requires <code>start_datetime</code> and <code>end_datetime</code> from common metadata to be set."},{"location":"item-spec/item-spec/#datetime","title":"datetime","text":"<p>This is likely the acquisition (in the case of single camera type captures) or the 'nominal' or representative time in the case of assets that are combined together. Though time can be a complex thing to capture, for this purpose keep in mind the STAC spec is primarily searching for data, so use whatever single date and time is most useful for a user to search for. STAC content extensions may further specify the meaning of the main <code>datetime</code> field, and many will also add more datetime fields. All times in STAC metadata should be in Coordinated Universal  Time (UTC). If there's clearly no meaningful single 'nominal' time, it is allowed to use <code>null</code> instead. In this case it is required to specify a temporal interval with the fields <code>start_datetime</code> and <code>end_datetime</code> from common metadata. For example, if your data is a time-series that covers 100 years, it's not very meaningful to set the datetime to a single timestamp as it would not be found in most searches that searches for a decade of data in that period although the Item actually covers the decade. See datetime selection in the best practices document for more information.</p>"},{"location":"item-spec/item-spec/#additional-fields","title":"Additional Fields","text":"<p>Providers should include metadata fields that are relevant for users of STAC, but it is recommended to select only those necessary for search. Where possible metadata fields should be mapped to the STAC Common Metadata and widely used extensions, to enable cross-catalog search on known fields.</p> <ul> <li>STAC Common Metadata - A list of fields commonly used throughout all domains. These optional fields are included for STAC Items by default.</li> <li>Extensions - Additional fields that are more specific, such as EO, View.</li> <li>Custom Extensions - It is generally allowed to add custom fields but it is recommended to add multiple fields for related values instead of a nested object, e.g., two fields <code>view:azimuth</code> and <code>view:off_nadir</code> instead of a field <code>view</code> with an object value containing the two fields. The convention (as used within Extensions) is for related fields  to use a common prefix on the field names to group them, e.g. <code>view</code>. A nested data structure should only be used when the data itself is nested, as with <code>bands</code>.</li> </ul>"},{"location":"item-spec/item-spec/#links","title":"Links","text":"<p>Each link in the <code>links</code> array must be a Link Object.</p>"},{"location":"item-spec/item-spec/#relation-types","title":"Relation types","text":"<p>All common relation types except for <code>item</code> can be used in Items. A <code>self</code> and <code>collection</code> links are STRONGLY RECOMMENDED. A link with this <code>rel</code> type is required for STAC item if the <code>collection</code> field in properties is present.</p> <p>[!NOTE] Dynamic catalogs can implement multiple parents through a dynamic browsing interface as they could dynamically create the parent link based on the desired browsing structure (though only 1 parent at a time). Multiple parents are allowed for other types than <code>application/json</code>.</p>"},{"location":"item-spec/item-spec/#collections","title":"Collections","text":"<p>Items are strongly recommended to provide a link to a STAC Collection definition. It is important as Collections provide additional information about a set of items, for example the license, provider and other information giving context on the overall set of data that an individual Item is a part of.</p> <p>If Items are part of a STAC Collection, the STAC Collection spec requires Items to link back to the Collection. Linking back must happen in two places:</p> <ol> <li>The field <code>collection</code> in an Item must be filled (see section 'Item fields'). It is the <code>id</code> of a STAC Collection.</li> <li>An Item must also provide a link to the STAC Collection using the <code>collection</code> relation type:    <code>js    \"links\": [      { \"rel\": \"collection\", \"href\": \"link/to/collection/record.json\" }    ]</code></li> </ol> <p>Multiple collections can point to an Item, but an Item can only point back to a single collection.</p>"},{"location":"item-spec/item-spec/#assets","title":"Assets","text":"<p>The property <code>assets</code> is a dictionary of Asset Objects, each with a unique key. Each asset refers to data associated with the Item that can be downloaded or streamed. This construct is further detailed in the Assets document.</p> <p>Assets in a STAC Item should include the main asset, as well as any 'sidecar' files that are related and help a client make sense of the data. Examples of this include extended metadata (in XML, JSON, etc.), unusable data masks, satellite ephemeris data, etc. Some assets (like Landsat data) are represented by multiple files - all should be linked to. It is generally recommended that different processing levels or formats are not exhaustively listed in an Item, but instead are represented by related Items that are linked to, but the best practices around this are still emerging.</p> <p>It is STRONGLY RECOMMENDED to add to each STAC Item</p> <ul> <li>a thumbnail with the role <code>thumbnail</code> for preview purposes</li> <li>one or more data files with the role <code>data</code></li> </ul>"},{"location":"item-spec/item-spec/#media-type-for-stac-item","title":"Media Type for STAC Item","text":"<p>A STAC Item is a GeoJSON file (RFC 7946), and thus should use the <code>application/geo+json</code> as the Media Type (previously known as the MIME Type).</p>"},{"location":"item-spec/item-spec/#extensions","title":"Extensions","text":"<p>STAC Items are extensible. Please refer to the extensions overview to find relevant extensions for STAC Items.</p>"}]}